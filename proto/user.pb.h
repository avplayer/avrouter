// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_user_2eproto__INCLUDED
#define PROTOBUF_user_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "address.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_user_2eproto();
void protobuf_AssignDesc_user_2eproto();
void protobuf_ShutdownFile_user_2eproto();

class client_hello;
class server_hello;
class login;
class login_result;
class username_availability_check;
class username_availability_result;
class user_register;
class user_register_result;
class user_cert_lost_request;
class user_cert_lost_verify;
class buddy;
class buddy_list;
class request_buddy_list;

enum login_result_login_result_code {
  login_result_login_result_code_LOGIN_SUCCEED = 0,
  login_result_login_result_code_NO_SUCH_USER = 1,
  login_result_login_result_code_PEREMISSON_DENIED = 2,
  login_result_login_result_code_PUBLIC_KEY_MISMATCH = 3
};
bool login_result_login_result_code_IsValid(int value);
const login_result_login_result_code login_result_login_result_code_login_result_code_MIN = login_result_login_result_code_LOGIN_SUCCEED;
const login_result_login_result_code login_result_login_result_code_login_result_code_MAX = login_result_login_result_code_PUBLIC_KEY_MISMATCH;
const int login_result_login_result_code_login_result_code_ARRAYSIZE = login_result_login_result_code_login_result_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* login_result_login_result_code_descriptor();
inline const ::std::string& login_result_login_result_code_Name(login_result_login_result_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    login_result_login_result_code_descriptor(), value);
}
inline bool login_result_login_result_code_Parse(
    const ::std::string& name, login_result_login_result_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<login_result_login_result_code>(
    login_result_login_result_code_descriptor(), name, value);
}
enum username_availability_result_username_availability_result_code {
  username_availability_result_username_availability_result_code_NAME_AVAILABLE = 0,
  username_availability_result_username_availability_result_code_NAME_DISALLOW = 1,
  username_availability_result_username_availability_result_code_NAME_TAKEN = 2
};
bool username_availability_result_username_availability_result_code_IsValid(int value);
const username_availability_result_username_availability_result_code username_availability_result_username_availability_result_code_username_availability_result_code_MIN = username_availability_result_username_availability_result_code_NAME_AVAILABLE;
const username_availability_result_username_availability_result_code username_availability_result_username_availability_result_code_username_availability_result_code_MAX = username_availability_result_username_availability_result_code_NAME_TAKEN;
const int username_availability_result_username_availability_result_code_username_availability_result_code_ARRAYSIZE = username_availability_result_username_availability_result_code_username_availability_result_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* username_availability_result_username_availability_result_code_descriptor();
inline const ::std::string& username_availability_result_username_availability_result_code_Name(username_availability_result_username_availability_result_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    username_availability_result_username_availability_result_code_descriptor(), value);
}
inline bool username_availability_result_username_availability_result_code_Parse(
    const ::std::string& name, username_availability_result_username_availability_result_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<username_availability_result_username_availability_result_code>(
    username_availability_result_username_availability_result_code_descriptor(), name, value);
}
enum user_register_result_user_register_result_code {
  user_register_result_user_register_result_code_REGISTER_SUCCEED = 0,
  user_register_result_user_register_result_code_REGISTER_FAILED_CA_BUSY = 1,
  user_register_result_user_register_result_code_REGISTER_FAILED_NAME_TAKEN = 2,
  user_register_result_user_register_result_code_REGISTER_FAILED_TOO_SHORT_KEY = 3,
  user_register_result_user_register_result_code_REGISTER_FAILED_NAME_DISALLOW = 4,
  user_register_result_user_register_result_code_REGISTER_FAILED_CA_DOWN = 5,
  user_register_result_user_register_result_code_REGISTER_FAILED_CSR_VERIFY_FAILURE = 6
};
bool user_register_result_user_register_result_code_IsValid(int value);
const user_register_result_user_register_result_code user_register_result_user_register_result_code_user_register_result_code_MIN = user_register_result_user_register_result_code_REGISTER_SUCCEED;
const user_register_result_user_register_result_code user_register_result_user_register_result_code_user_register_result_code_MAX = user_register_result_user_register_result_code_REGISTER_FAILED_CSR_VERIFY_FAILURE;
const int user_register_result_user_register_result_code_user_register_result_code_ARRAYSIZE = user_register_result_user_register_result_code_user_register_result_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* user_register_result_user_register_result_code_descriptor();
inline const ::std::string& user_register_result_user_register_result_code_Name(user_register_result_user_register_result_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    user_register_result_user_register_result_code_descriptor(), value);
}
inline bool user_register_result_user_register_result_code_Parse(
    const ::std::string& name, user_register_result_user_register_result_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<user_register_result_user_register_result_code>(
    user_register_result_user_register_result_code_descriptor(), name, value);
}
// ===================================================================

class client_hello : public ::google::protobuf::Message {
 public:
  client_hello();
  virtual ~client_hello();

  client_hello(const client_hello& from);

  inline client_hello& operator=(const client_hello& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline client_hello& operator=(client_hello&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  client_hello(client_hello&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const client_hello& default_instance();

  void Swap(client_hello* other);

  // implements Message ----------------------------------------------

  inline client_hello* New() const { return New(NULL); }

  client_hello* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const client_hello& from);
  void MergeFrom(const client_hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(client_hello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client = 1;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 1;
  inline const ::std::string& client() const;
  inline void set_client(const ::std::string& value);
  inline void set_client(const char* value);
  inline void set_client(const char* value, size_t size);
  inline ::std::string* mutable_client();
  inline ::std::string* release_client();
  inline void set_allocated_client(::std::string* client);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required bytes random_g = 3;
  inline bool has_random_g() const;
  inline void clear_random_g();
  static const int kRandomGFieldNumber = 3;
  inline const ::std::string& random_g() const;
  inline void set_random_g(const ::std::string& value);
  inline void set_random_g(const char* value);
  inline void set_random_g(const void* value, size_t size);
  inline ::std::string* mutable_random_g();
  inline ::std::string* release_random_g();
  inline void set_allocated_random_g(::std::string* random_g);

  // required bytes random_p = 4;
  inline bool has_random_p() const;
  inline void clear_random_p();
  static const int kRandomPFieldNumber = 4;
  inline const ::std::string& random_p() const;
  inline void set_random_p(const ::std::string& value);
  inline void set_random_p(const char* value);
  inline void set_random_p(const void* value, size_t size);
  inline ::std::string* mutable_random_p();
  inline ::std::string* release_random_p();
  inline void set_allocated_random_p(::std::string* random_p);

  // required bytes random_pub_key = 5;
  inline bool has_random_pub_key() const;
  inline void clear_random_pub_key();
  static const int kRandomPubKeyFieldNumber = 5;
  inline const ::std::string& random_pub_key() const;
  inline void set_random_pub_key(const ::std::string& value);
  inline void set_random_pub_key(const char* value);
  inline void set_random_pub_key(const void* value, size_t size);
  inline ::std::string* mutable_random_pub_key();
  inline ::std::string* release_random_pub_key();
  inline void set_allocated_random_pub_key(::std::string* random_pub_key);

  // @@protoc_insertion_point(class_scope:proto.client_hello)
 private:
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_random_g();
  inline void clear_has_random_g();
  inline void set_has_random_p();
  inline void clear_has_random_p();
  inline void set_has_random_pub_key();
  inline void clear_has_random_pub_key();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_;
  ::google::protobuf::internal::ArenaStringPtr random_g_;
  ::google::protobuf::internal::ArenaStringPtr random_p_;
  ::google::protobuf::internal::ArenaStringPtr random_pub_key_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static client_hello* default_instance_;
};
// -------------------------------------------------------------------

class server_hello : public ::google::protobuf::Message {
 public:
  server_hello();
  virtual ~server_hello();

  server_hello(const server_hello& from);

  inline server_hello& operator=(const server_hello& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline server_hello& operator=(server_hello&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  server_hello(server_hello&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const server_hello& default_instance();

  void Swap(server_hello* other);

  // implements Message ----------------------------------------------

  inline server_hello* New() const { return New(NULL); }

  server_hello* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const server_hello& from);
  void MergeFrom(const server_hello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(server_hello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string servername = 1;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServernameFieldNumber = 1;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required bytes random_pub_key = 3;
  inline bool has_random_pub_key() const;
  inline void clear_random_pub_key();
  static const int kRandomPubKeyFieldNumber = 3;
  inline const ::std::string& random_pub_key() const;
  inline void set_random_pub_key(const ::std::string& value);
  inline void set_random_pub_key(const char* value);
  inline void set_random_pub_key(const void* value, size_t size);
  inline ::std::string* mutable_random_pub_key();
  inline ::std::string* release_random_pub_key();
  inline void set_allocated_random_pub_key(::std::string* random_pub_key);

  // required string server_av_address = 4;
  inline bool has_server_av_address() const;
  inline void clear_server_av_address();
  static const int kServerAvAddressFieldNumber = 4;
  inline const ::std::string& server_av_address() const;
  inline void set_server_av_address(const ::std::string& value);
  inline void set_server_av_address(const char* value);
  inline void set_server_av_address(const char* value, size_t size);
  inline ::std::string* mutable_server_av_address();
  inline ::std::string* release_server_av_address();
  inline void set_allocated_server_av_address(::std::string* server_av_address);

  // @@protoc_insertion_point(class_scope:proto.server_hello)
 private:
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_random_pub_key();
  inline void clear_has_random_pub_key();
  inline void set_has_server_av_address();
  inline void clear_has_server_av_address();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr servername_;
  ::google::protobuf::internal::ArenaStringPtr random_pub_key_;
  ::google::protobuf::internal::ArenaStringPtr server_av_address_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static server_hello* default_instance_;
};
// -------------------------------------------------------------------

class login : public ::google::protobuf::Message {
 public:
  login();
  virtual ~login();

  login(const login& from);

  inline login& operator=(const login& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline login& operator=(login&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  login(login&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login& default_instance();

  void Swap(login* other);

  // implements Message ----------------------------------------------

  inline login* New() const { return New(NULL); }

  login* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login& from);
  void MergeFrom(const login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes user_cert = 1;
  inline bool has_user_cert() const;
  inline void clear_user_cert();
  static const int kUserCertFieldNumber = 1;
  inline const ::std::string& user_cert() const;
  inline void set_user_cert(const ::std::string& value);
  inline void set_user_cert(const char* value);
  inline void set_user_cert(const void* value, size_t size);
  inline ::std::string* mutable_user_cert();
  inline ::std::string* release_user_cert();
  inline void set_allocated_user_cert(::std::string* user_cert);

  // required bytes encryped_radom_key = 2;
  inline bool has_encryped_radom_key() const;
  inline void clear_encryped_radom_key();
  static const int kEncrypedRadomKeyFieldNumber = 2;
  inline const ::std::string& encryped_radom_key() const;
  inline void set_encryped_radom_key(const ::std::string& value);
  inline void set_encryped_radom_key(const char* value);
  inline void set_encryped_radom_key(const void* value, size_t size);
  inline ::std::string* mutable_encryped_radom_key();
  inline ::std::string* release_encryped_radom_key();
  inline void set_allocated_encryped_radom_key(::std::string* encryped_radom_key);

  // optional string other_info = 3;
  inline bool has_other_info() const;
  inline void clear_other_info();
  static const int kOtherInfoFieldNumber = 3;
  inline const ::std::string& other_info() const;
  inline void set_other_info(const ::std::string& value);
  inline void set_other_info(const char* value);
  inline void set_other_info(const char* value, size_t size);
  inline ::std::string* mutable_other_info();
  inline ::std::string* release_other_info();
  inline void set_allocated_other_info(::std::string* other_info);

  // @@protoc_insertion_point(class_scope:proto.login)
 private:
  inline void set_has_user_cert();
  inline void clear_has_user_cert();
  inline void set_has_encryped_radom_key();
  inline void clear_has_encryped_radom_key();
  inline void set_has_other_info();
  inline void clear_has_other_info();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_cert_;
  ::google::protobuf::internal::ArenaStringPtr encryped_radom_key_;
  ::google::protobuf::internal::ArenaStringPtr other_info_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static login* default_instance_;
};
// -------------------------------------------------------------------

class login_result : public ::google::protobuf::Message {
 public:
  login_result();
  virtual ~login_result();

  login_result(const login_result& from);

  inline login_result& operator=(const login_result& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline login_result& operator=(login_result&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  login_result(login_result&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const login_result& default_instance();

  void Swap(login_result* other);

  // implements Message ----------------------------------------------

  inline login_result* New() const { return New(NULL); }

  login_result* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const login_result& from);
  void MergeFrom(const login_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(login_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef login_result_login_result_code login_result_code;
  static const login_result_code LOGIN_SUCCEED = login_result_login_result_code_LOGIN_SUCCEED;
  static const login_result_code NO_SUCH_USER = login_result_login_result_code_NO_SUCH_USER;
  static const login_result_code PEREMISSON_DENIED = login_result_login_result_code_PEREMISSON_DENIED;
  static const login_result_code PUBLIC_KEY_MISMATCH = login_result_login_result_code_PUBLIC_KEY_MISMATCH;
  static inline bool login_result_code_IsValid(int value) {
    return login_result_login_result_code_IsValid(value);
  }
  static const login_result_code login_result_code_MIN =
    login_result_login_result_code_login_result_code_MIN;
  static const login_result_code login_result_code_MAX =
    login_result_login_result_code_login_result_code_MAX;
  static const int login_result_code_ARRAYSIZE =
    login_result_login_result_code_login_result_code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  login_result_code_descriptor() {
    return login_result_login_result_code_descriptor();
  }
  static inline const ::std::string& login_result_code_Name(login_result_code value) {
    return login_result_login_result_code_Name(value);
  }
  static inline bool login_result_code_Parse(const ::std::string& name,
      login_result_code* value) {
    return login_result_login_result_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.login_result.login_result_code result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::proto::login_result_login_result_code result() const;
  inline void set_result(::proto::login_result_login_result_code value);

  // @@protoc_insertion_point(class_scope:proto.login_result)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static login_result* default_instance_;
};
// -------------------------------------------------------------------

class username_availability_check : public ::google::protobuf::Message {
 public:
  username_availability_check();
  virtual ~username_availability_check();

  username_availability_check(const username_availability_check& from);

  inline username_availability_check& operator=(const username_availability_check& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline username_availability_check& operator=(username_availability_check&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  username_availability_check(username_availability_check&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const username_availability_check& default_instance();

  void Swap(username_availability_check* other);

  // implements Message ----------------------------------------------

  inline username_availability_check* New() const { return New(NULL); }

  username_availability_check* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const username_availability_check& from);
  void MergeFrom(const username_availability_check& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(username_availability_check* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:proto.username_availability_check)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static username_availability_check* default_instance_;
};
// -------------------------------------------------------------------

class username_availability_result : public ::google::protobuf::Message {
 public:
  username_availability_result();
  virtual ~username_availability_result();

  username_availability_result(const username_availability_result& from);

  inline username_availability_result& operator=(const username_availability_result& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline username_availability_result& operator=(username_availability_result&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  username_availability_result(username_availability_result&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const username_availability_result& default_instance();

  void Swap(username_availability_result* other);

  // implements Message ----------------------------------------------

  inline username_availability_result* New() const { return New(NULL); }

  username_availability_result* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const username_availability_result& from);
  void MergeFrom(const username_availability_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(username_availability_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef username_availability_result_username_availability_result_code username_availability_result_code;
  static const username_availability_result_code NAME_AVAILABLE = username_availability_result_username_availability_result_code_NAME_AVAILABLE;
  static const username_availability_result_code NAME_DISALLOW = username_availability_result_username_availability_result_code_NAME_DISALLOW;
  static const username_availability_result_code NAME_TAKEN = username_availability_result_username_availability_result_code_NAME_TAKEN;
  static inline bool username_availability_result_code_IsValid(int value) {
    return username_availability_result_username_availability_result_code_IsValid(value);
  }
  static const username_availability_result_code username_availability_result_code_MIN =
    username_availability_result_username_availability_result_code_username_availability_result_code_MIN;
  static const username_availability_result_code username_availability_result_code_MAX =
    username_availability_result_username_availability_result_code_username_availability_result_code_MAX;
  static const int username_availability_result_code_ARRAYSIZE =
    username_availability_result_username_availability_result_code_username_availability_result_code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  username_availability_result_code_descriptor() {
    return username_availability_result_username_availability_result_code_descriptor();
  }
  static inline const ::std::string& username_availability_result_code_Name(username_availability_result_code value) {
    return username_availability_result_username_availability_result_code_Name(value);
  }
  static inline bool username_availability_result_code_Parse(const ::std::string& name,
      username_availability_result_code* value) {
    return username_availability_result_username_availability_result_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.username_availability_result.username_availability_result_code result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::proto::username_availability_result_username_availability_result_code result() const;
  inline void set_result(::proto::username_availability_result_username_availability_result_code value);

  // @@protoc_insertion_point(class_scope:proto.username_availability_result)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static username_availability_result* default_instance_;
};
// -------------------------------------------------------------------

class user_register : public ::google::protobuf::Message {
 public:
  user_register();
  virtual ~user_register();

  user_register(const user_register& from);

  inline user_register& operator=(const user_register& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline user_register& operator=(user_register&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  user_register(user_register&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_register& default_instance();

  void Swap(user_register* other);

  // implements Message ----------------------------------------------

  inline user_register* New() const { return New(NULL); }

  user_register* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_register& from);
  void MergeFrom(const user_register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(user_register* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required bytes rsa_pubkey = 2;
  inline bool has_rsa_pubkey() const;
  inline void clear_rsa_pubkey();
  static const int kRsaPubkeyFieldNumber = 2;
  inline const ::std::string& rsa_pubkey() const;
  inline void set_rsa_pubkey(const ::std::string& value);
  inline void set_rsa_pubkey(const char* value);
  inline void set_rsa_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_rsa_pubkey();
  inline ::std::string* release_rsa_pubkey();
  inline void set_allocated_rsa_pubkey(::std::string* rsa_pubkey);

  // required bytes CSR = 3;
  inline bool has_csr() const;
  inline void clear_csr();
  static const int kCSRFieldNumber = 3;
  inline const ::std::string& csr() const;
  inline void set_csr(const ::std::string& value);
  inline void set_csr(const char* value);
  inline void set_csr(const void* value, size_t size);
  inline ::std::string* mutable_csr();
  inline ::std::string* release_csr();
  inline void set_allocated_csr(::std::string* csr);

  // optional string mail_address = 4;
  inline bool has_mail_address() const;
  inline void clear_mail_address();
  static const int kMailAddressFieldNumber = 4;
  inline const ::std::string& mail_address() const;
  inline void set_mail_address(const ::std::string& value);
  inline void set_mail_address(const char* value);
  inline void set_mail_address(const char* value, size_t size);
  inline ::std::string* mutable_mail_address();
  inline ::std::string* release_mail_address();
  inline void set_allocated_mail_address(::std::string* mail_address);

  // optional string cell_phone = 5;
  inline bool has_cell_phone() const;
  inline void clear_cell_phone();
  static const int kCellPhoneFieldNumber = 5;
  inline const ::std::string& cell_phone() const;
  inline void set_cell_phone(const ::std::string& value);
  inline void set_cell_phone(const char* value);
  inline void set_cell_phone(const char* value, size_t size);
  inline ::std::string* mutable_cell_phone();
  inline ::std::string* release_cell_phone();
  inline void set_allocated_cell_phone(::std::string* cell_phone);

  // @@protoc_insertion_point(class_scope:proto.user_register)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_rsa_pubkey();
  inline void clear_has_rsa_pubkey();
  inline void set_has_csr();
  inline void clear_has_csr();
  inline void set_has_mail_address();
  inline void clear_has_mail_address();
  inline void set_has_cell_phone();
  inline void clear_has_cell_phone();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr rsa_pubkey_;
  ::google::protobuf::internal::ArenaStringPtr csr_;
  ::google::protobuf::internal::ArenaStringPtr mail_address_;
  ::google::protobuf::internal::ArenaStringPtr cell_phone_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static user_register* default_instance_;
};
// -------------------------------------------------------------------

class user_register_result : public ::google::protobuf::Message {
 public:
  user_register_result();
  virtual ~user_register_result();

  user_register_result(const user_register_result& from);

  inline user_register_result& operator=(const user_register_result& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline user_register_result& operator=(user_register_result&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  user_register_result(user_register_result&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_register_result& default_instance();

  void Swap(user_register_result* other);

  // implements Message ----------------------------------------------

  inline user_register_result* New() const { return New(NULL); }

  user_register_result* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_register_result& from);
  void MergeFrom(const user_register_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(user_register_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef user_register_result_user_register_result_code user_register_result_code;
  static const user_register_result_code REGISTER_SUCCEED = user_register_result_user_register_result_code_REGISTER_SUCCEED;
  static const user_register_result_code REGISTER_FAILED_CA_BUSY = user_register_result_user_register_result_code_REGISTER_FAILED_CA_BUSY;
  static const user_register_result_code REGISTER_FAILED_NAME_TAKEN = user_register_result_user_register_result_code_REGISTER_FAILED_NAME_TAKEN;
  static const user_register_result_code REGISTER_FAILED_TOO_SHORT_KEY = user_register_result_user_register_result_code_REGISTER_FAILED_TOO_SHORT_KEY;
  static const user_register_result_code REGISTER_FAILED_NAME_DISALLOW = user_register_result_user_register_result_code_REGISTER_FAILED_NAME_DISALLOW;
  static const user_register_result_code REGISTER_FAILED_CA_DOWN = user_register_result_user_register_result_code_REGISTER_FAILED_CA_DOWN;
  static const user_register_result_code REGISTER_FAILED_CSR_VERIFY_FAILURE = user_register_result_user_register_result_code_REGISTER_FAILED_CSR_VERIFY_FAILURE;
  static inline bool user_register_result_code_IsValid(int value) {
    return user_register_result_user_register_result_code_IsValid(value);
  }
  static const user_register_result_code user_register_result_code_MIN =
    user_register_result_user_register_result_code_user_register_result_code_MIN;
  static const user_register_result_code user_register_result_code_MAX =
    user_register_result_user_register_result_code_user_register_result_code_MAX;
  static const int user_register_result_code_ARRAYSIZE =
    user_register_result_user_register_result_code_user_register_result_code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  user_register_result_code_descriptor() {
    return user_register_result_user_register_result_code_descriptor();
  }
  static inline const ::std::string& user_register_result_code_Name(user_register_result_code value) {
    return user_register_result_user_register_result_code_Name(value);
  }
  static inline bool user_register_result_code_Parse(const ::std::string& name,
      user_register_result_code* value) {
    return user_register_result_user_register_result_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .proto.user_register_result.user_register_result_code result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::proto::user_register_result_user_register_result_code result() const;
  inline void set_result(::proto::user_register_result_user_register_result_code value);

  // optional bytes cert = 2;
  inline bool has_cert() const;
  inline void clear_cert();
  static const int kCertFieldNumber = 2;
  inline const ::std::string& cert() const;
  inline void set_cert(const ::std::string& value);
  inline void set_cert(const char* value);
  inline void set_cert(const void* value, size_t size);
  inline ::std::string* mutable_cert();
  inline ::std::string* release_cert();
  inline void set_allocated_cert(::std::string* cert);

  // @@protoc_insertion_point(class_scope:proto.user_register_result)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_cert();
  inline void clear_has_cert();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr cert_;
  int result_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static user_register_result* default_instance_;
};
// -------------------------------------------------------------------

class user_cert_lost_request : public ::google::protobuf::Message {
 public:
  user_cert_lost_request();
  virtual ~user_cert_lost_request();

  user_cert_lost_request(const user_cert_lost_request& from);

  inline user_cert_lost_request& operator=(const user_cert_lost_request& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline user_cert_lost_request& operator=(user_cert_lost_request&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  user_cert_lost_request(user_cert_lost_request&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_cert_lost_request& default_instance();

  void Swap(user_cert_lost_request* other);

  // implements Message ----------------------------------------------

  inline user_cert_lost_request* New() const { return New(NULL); }

  user_cert_lost_request* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_cert_lost_request& from);
  void MergeFrom(const user_cert_lost_request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(user_cert_lost_request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional string mail_address = 3;
  inline bool has_mail_address() const;
  inline void clear_mail_address();
  static const int kMailAddressFieldNumber = 3;
  inline const ::std::string& mail_address() const;
  inline void set_mail_address(const ::std::string& value);
  inline void set_mail_address(const char* value);
  inline void set_mail_address(const char* value, size_t size);
  inline ::std::string* mutable_mail_address();
  inline ::std::string* release_mail_address();
  inline void set_allocated_mail_address(::std::string* mail_address);

  // optional string cell_phone = 4;
  inline bool has_cell_phone() const;
  inline void clear_cell_phone();
  static const int kCellPhoneFieldNumber = 4;
  inline const ::std::string& cell_phone() const;
  inline void set_cell_phone(const ::std::string& value);
  inline void set_cell_phone(const char* value);
  inline void set_cell_phone(const char* value, size_t size);
  inline ::std::string* mutable_cell_phone();
  inline ::std::string* release_cell_phone();
  inline void set_allocated_cell_phone(::std::string* cell_phone);

  // @@protoc_insertion_point(class_scope:proto.user_cert_lost_request)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_mail_address();
  inline void clear_has_mail_address();
  inline void set_has_cell_phone();
  inline void clear_has_cell_phone();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr mail_address_;
  ::google::protobuf::internal::ArenaStringPtr cell_phone_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static user_cert_lost_request* default_instance_;
};
// -------------------------------------------------------------------

class user_cert_lost_verify : public ::google::protobuf::Message {
 public:
  user_cert_lost_verify();
  virtual ~user_cert_lost_verify();

  user_cert_lost_verify(const user_cert_lost_verify& from);

  inline user_cert_lost_verify& operator=(const user_cert_lost_verify& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline user_cert_lost_verify& operator=(user_cert_lost_verify&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  user_cert_lost_verify(user_cert_lost_verify&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_cert_lost_verify& default_instance();

  void Swap(user_cert_lost_verify* other);

  // implements Message ----------------------------------------------

  inline user_cert_lost_verify* New() const { return New(NULL); }

  user_cert_lost_verify* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_cert_lost_verify& from);
  void MergeFrom(const user_cert_lost_verify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(user_cert_lost_verify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string secret_code = 1;
  inline bool has_secret_code() const;
  inline void clear_secret_code();
  static const int kSecretCodeFieldNumber = 1;
  inline const ::std::string& secret_code() const;
  inline void set_secret_code(const ::std::string& value);
  inline void set_secret_code(const char* value);
  inline void set_secret_code(const char* value, size_t size);
  inline ::std::string* mutable_secret_code();
  inline ::std::string* release_secret_code();
  inline void set_allocated_secret_code(::std::string* secret_code);

  // @@protoc_insertion_point(class_scope:proto.user_cert_lost_verify)
 private:
  inline void set_has_secret_code();
  inline void clear_has_secret_code();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr secret_code_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static user_cert_lost_verify* default_instance_;
};
// -------------------------------------------------------------------

class buddy : public ::google::protobuf::Message {
 public:
  buddy();
  virtual ~buddy();

  buddy(const buddy& from);

  inline buddy& operator=(const buddy& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline buddy& operator=(buddy&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  buddy(buddy&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buddy& default_instance();

  void Swap(buddy* other);

  // implements Message ----------------------------------------------

  inline buddy* New() const { return New(NULL); }

  buddy* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buddy& from);
  void MergeFrom(const buddy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(buddy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.av_address addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline const ::proto::av_address& addr() const;
  inline ::proto::av_address* mutable_addr();
  inline ::proto::av_address* release_addr();
  inline void set_allocated_addr(::proto::av_address* addr);

  // optional string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // repeated string labels = 3;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 3;
  inline const ::std::string& labels(int index) const;
  inline ::std::string* mutable_labels(int index);
  inline void set_labels(int index, const ::std::string& value);
  inline void set_labels(int index, const char* value);
  inline void set_labels(int index, const char* value, size_t size);
  inline ::std::string* add_labels();
  inline void add_labels(const ::std::string& value);
  inline void add_labels(const char* value);
  inline void add_labels(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_labels();

  // @@protoc_insertion_point(class_scope:proto.buddy)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_nick();
  inline void clear_has_nick();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::av_address* addr_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::RepeatedPtrField< ::std::string> labels_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static buddy* default_instance_;
};
// -------------------------------------------------------------------

class buddy_list : public ::google::protobuf::Message {
 public:
  buddy_list();
  virtual ~buddy_list();

  buddy_list(const buddy_list& from);

  inline buddy_list& operator=(const buddy_list& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline buddy_list& operator=(buddy_list&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  buddy_list(buddy_list&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buddy_list& default_instance();

  void Swap(buddy_list* other);

  // implements Message ----------------------------------------------

  inline buddy_list* New() const { return New(NULL); }

  buddy_list* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buddy_list& from);
  void MergeFrom(const buddy_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(buddy_list* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.buddy buddies = 1;
  inline int buddies_size() const;
  inline void clear_buddies();
  static const int kBuddiesFieldNumber = 1;
  inline const ::proto::buddy& buddies(int index) const;
  inline ::proto::buddy* mutable_buddies(int index);
  inline ::proto::buddy* add_buddies();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::buddy >&
      buddies() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::buddy >*
      mutable_buddies();

  // @@protoc_insertion_point(class_scope:proto.buddy_list)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::proto::buddy > buddies_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static buddy_list* default_instance_;
};
// -------------------------------------------------------------------

class request_buddy_list : public ::google::protobuf::Message {
 public:
  request_buddy_list();
  virtual ~request_buddy_list();

  request_buddy_list(const request_buddy_list& from);

  inline request_buddy_list& operator=(const request_buddy_list& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline request_buddy_list& operator=(request_buddy_list&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  request_buddy_list(request_buddy_list&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const request_buddy_list& default_instance();

  void Swap(request_buddy_list* other);

  // implements Message ----------------------------------------------

  inline request_buddy_list* New() const { return New(NULL); }

  request_buddy_list* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const request_buddy_list& from);
  void MergeFrom(const request_buddy_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(request_buddy_list* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:proto.request_buddy_list)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_user_2eproto();
  friend void protobuf_AssignDesc_user_2eproto();
  friend void protobuf_ShutdownFile_user_2eproto();

  void InitAsDefaultInstance();
  static request_buddy_list* default_instance_;
};
// ===================================================================


// ===================================================================

// client_hello

// required string client = 1;
inline bool client_hello::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void client_hello::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
inline void client_hello::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void client_hello::clear_client() {
  client_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client();
}
inline const ::std::string& client_hello::client() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.client)
  return client_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void client_hello::set_client(const ::std::string& value) {
  set_has_client();
  client_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.client_hello.client)
}
inline void client_hello::set_client(const char* value) {
  set_has_client();
  client_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.client_hello.client)
}
inline void client_hello::set_client(const char* value, size_t size) {
  set_has_client();
  client_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.client_hello.client)
}
inline ::std::string* client_hello::mutable_client() {
  set_has_client();
  // @@protoc_insertion_point(field_mutable:proto.client_hello.client)
  return client_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* client_hello::release_client() {
  clear_has_client();
  return client_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void client_hello::set_allocated_client(::std::string* client) {
  if (client != NULL) {
    set_has_client();
  } else {
    clear_has_client();
  }
  client_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client);
  // @@protoc_insertion_point(field_set_allocated:proto.client_hello.client)
}

// required uint32 version = 2;
inline bool client_hello::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void client_hello::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void client_hello::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void client_hello::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 client_hello::version() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.version)
  return version_;
}
inline void client_hello::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:proto.client_hello.version)
}

// required bytes random_g = 3;
inline bool client_hello::has_random_g() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void client_hello::set_has_random_g() {
  _has_bits_[0] |= 0x00000004u;
}
inline void client_hello::clear_has_random_g() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void client_hello::clear_random_g() {
  random_g_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_random_g();
}
inline const ::std::string& client_hello::random_g() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.random_g)
  return random_g_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void client_hello::set_random_g(const ::std::string& value) {
  set_has_random_g();
  random_g_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.client_hello.random_g)
}
inline void client_hello::set_random_g(const char* value) {
  set_has_random_g();
  random_g_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.client_hello.random_g)
}
inline void client_hello::set_random_g(const void* value, size_t size) {
  set_has_random_g();
  random_g_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.client_hello.random_g)
}
inline ::std::string* client_hello::mutable_random_g() {
  set_has_random_g();
  // @@protoc_insertion_point(field_mutable:proto.client_hello.random_g)
  return random_g_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* client_hello::release_random_g() {
  clear_has_random_g();
  return random_g_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void client_hello::set_allocated_random_g(::std::string* random_g) {
  if (random_g != NULL) {
    set_has_random_g();
  } else {
    clear_has_random_g();
  }
  random_g_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), random_g);
  // @@protoc_insertion_point(field_set_allocated:proto.client_hello.random_g)
}

// required bytes random_p = 4;
inline bool client_hello::has_random_p() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void client_hello::set_has_random_p() {
  _has_bits_[0] |= 0x00000008u;
}
inline void client_hello::clear_has_random_p() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void client_hello::clear_random_p() {
  random_p_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_random_p();
}
inline const ::std::string& client_hello::random_p() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.random_p)
  return random_p_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void client_hello::set_random_p(const ::std::string& value) {
  set_has_random_p();
  random_p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.client_hello.random_p)
}
inline void client_hello::set_random_p(const char* value) {
  set_has_random_p();
  random_p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.client_hello.random_p)
}
inline void client_hello::set_random_p(const void* value, size_t size) {
  set_has_random_p();
  random_p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.client_hello.random_p)
}
inline ::std::string* client_hello::mutable_random_p() {
  set_has_random_p();
  // @@protoc_insertion_point(field_mutable:proto.client_hello.random_p)
  return random_p_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* client_hello::release_random_p() {
  clear_has_random_p();
  return random_p_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void client_hello::set_allocated_random_p(::std::string* random_p) {
  if (random_p != NULL) {
    set_has_random_p();
  } else {
    clear_has_random_p();
  }
  random_p_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), random_p);
  // @@protoc_insertion_point(field_set_allocated:proto.client_hello.random_p)
}

// required bytes random_pub_key = 5;
inline bool client_hello::has_random_pub_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void client_hello::set_has_random_pub_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void client_hello::clear_has_random_pub_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void client_hello::clear_random_pub_key() {
  random_pub_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_random_pub_key();
}
inline const ::std::string& client_hello::random_pub_key() const {
  // @@protoc_insertion_point(field_get:proto.client_hello.random_pub_key)
  return random_pub_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void client_hello::set_random_pub_key(const ::std::string& value) {
  set_has_random_pub_key();
  random_pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.client_hello.random_pub_key)
}
inline void client_hello::set_random_pub_key(const char* value) {
  set_has_random_pub_key();
  random_pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.client_hello.random_pub_key)
}
inline void client_hello::set_random_pub_key(const void* value, size_t size) {
  set_has_random_pub_key();
  random_pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.client_hello.random_pub_key)
}
inline ::std::string* client_hello::mutable_random_pub_key() {
  set_has_random_pub_key();
  // @@protoc_insertion_point(field_mutable:proto.client_hello.random_pub_key)
  return random_pub_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* client_hello::release_random_pub_key() {
  clear_has_random_pub_key();
  return random_pub_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void client_hello::set_allocated_random_pub_key(::std::string* random_pub_key) {
  if (random_pub_key != NULL) {
    set_has_random_pub_key();
  } else {
    clear_has_random_pub_key();
  }
  random_pub_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), random_pub_key);
  // @@protoc_insertion_point(field_set_allocated:proto.client_hello.random_pub_key)
}

// -------------------------------------------------------------------

// server_hello

// required string servername = 1;
inline bool server_hello::has_servername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void server_hello::set_has_servername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void server_hello::clear_has_servername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void server_hello::clear_servername() {
  servername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_servername();
}
inline const ::std::string& server_hello::servername() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.servername)
  return servername_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void server_hello::set_servername(const ::std::string& value) {
  set_has_servername();
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.server_hello.servername)
}
inline void server_hello::set_servername(const char* value) {
  set_has_servername();
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.server_hello.servername)
}
inline void server_hello::set_servername(const char* value, size_t size) {
  set_has_servername();
  servername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.server_hello.servername)
}
inline ::std::string* server_hello::mutable_servername() {
  set_has_servername();
  // @@protoc_insertion_point(field_mutable:proto.server_hello.servername)
  return servername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* server_hello::release_servername() {
  clear_has_servername();
  return servername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void server_hello::set_allocated_servername(::std::string* servername) {
  if (servername != NULL) {
    set_has_servername();
  } else {
    clear_has_servername();
  }
  servername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), servername);
  // @@protoc_insertion_point(field_set_allocated:proto.server_hello.servername)
}

// required uint32 version = 2;
inline bool server_hello::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void server_hello::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void server_hello::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void server_hello::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 server_hello::version() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.version)
  return version_;
}
inline void server_hello::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:proto.server_hello.version)
}

// required bytes random_pub_key = 3;
inline bool server_hello::has_random_pub_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void server_hello::set_has_random_pub_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void server_hello::clear_has_random_pub_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void server_hello::clear_random_pub_key() {
  random_pub_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_random_pub_key();
}
inline const ::std::string& server_hello::random_pub_key() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.random_pub_key)
  return random_pub_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void server_hello::set_random_pub_key(const ::std::string& value) {
  set_has_random_pub_key();
  random_pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.server_hello.random_pub_key)
}
inline void server_hello::set_random_pub_key(const char* value) {
  set_has_random_pub_key();
  random_pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.server_hello.random_pub_key)
}
inline void server_hello::set_random_pub_key(const void* value, size_t size) {
  set_has_random_pub_key();
  random_pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.server_hello.random_pub_key)
}
inline ::std::string* server_hello::mutable_random_pub_key() {
  set_has_random_pub_key();
  // @@protoc_insertion_point(field_mutable:proto.server_hello.random_pub_key)
  return random_pub_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* server_hello::release_random_pub_key() {
  clear_has_random_pub_key();
  return random_pub_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void server_hello::set_allocated_random_pub_key(::std::string* random_pub_key) {
  if (random_pub_key != NULL) {
    set_has_random_pub_key();
  } else {
    clear_has_random_pub_key();
  }
  random_pub_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), random_pub_key);
  // @@protoc_insertion_point(field_set_allocated:proto.server_hello.random_pub_key)
}

// required string server_av_address = 4;
inline bool server_hello::has_server_av_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void server_hello::set_has_server_av_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void server_hello::clear_has_server_av_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void server_hello::clear_server_av_address() {
  server_av_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_av_address();
}
inline const ::std::string& server_hello::server_av_address() const {
  // @@protoc_insertion_point(field_get:proto.server_hello.server_av_address)
  return server_av_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void server_hello::set_server_av_address(const ::std::string& value) {
  set_has_server_av_address();
  server_av_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.server_hello.server_av_address)
}
inline void server_hello::set_server_av_address(const char* value) {
  set_has_server_av_address();
  server_av_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.server_hello.server_av_address)
}
inline void server_hello::set_server_av_address(const char* value, size_t size) {
  set_has_server_av_address();
  server_av_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.server_hello.server_av_address)
}
inline ::std::string* server_hello::mutable_server_av_address() {
  set_has_server_av_address();
  // @@protoc_insertion_point(field_mutable:proto.server_hello.server_av_address)
  return server_av_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* server_hello::release_server_av_address() {
  clear_has_server_av_address();
  return server_av_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void server_hello::set_allocated_server_av_address(::std::string* server_av_address) {
  if (server_av_address != NULL) {
    set_has_server_av_address();
  } else {
    clear_has_server_av_address();
  }
  server_av_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_av_address);
  // @@protoc_insertion_point(field_set_allocated:proto.server_hello.server_av_address)
}

// -------------------------------------------------------------------

// login

// required bytes user_cert = 1;
inline bool login::has_user_cert() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login::set_has_user_cert() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login::clear_has_user_cert() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login::clear_user_cert() {
  user_cert_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_cert();
}
inline const ::std::string& login::user_cert() const {
  // @@protoc_insertion_point(field_get:proto.login.user_cert)
  return user_cert_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login::set_user_cert(const ::std::string& value) {
  set_has_user_cert();
  user_cert_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.login.user_cert)
}
inline void login::set_user_cert(const char* value) {
  set_has_user_cert();
  user_cert_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.login.user_cert)
}
inline void login::set_user_cert(const void* value, size_t size) {
  set_has_user_cert();
  user_cert_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.login.user_cert)
}
inline ::std::string* login::mutable_user_cert() {
  set_has_user_cert();
  // @@protoc_insertion_point(field_mutable:proto.login.user_cert)
  return user_cert_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* login::release_user_cert() {
  clear_has_user_cert();
  return user_cert_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login::set_allocated_user_cert(::std::string* user_cert) {
  if (user_cert != NULL) {
    set_has_user_cert();
  } else {
    clear_has_user_cert();
  }
  user_cert_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_cert);
  // @@protoc_insertion_point(field_set_allocated:proto.login.user_cert)
}

// required bytes encryped_radom_key = 2;
inline bool login::has_encryped_radom_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void login::set_has_encryped_radom_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void login::clear_has_encryped_radom_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void login::clear_encryped_radom_key() {
  encryped_radom_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_encryped_radom_key();
}
inline const ::std::string& login::encryped_radom_key() const {
  // @@protoc_insertion_point(field_get:proto.login.encryped_radom_key)
  return encryped_radom_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login::set_encryped_radom_key(const ::std::string& value) {
  set_has_encryped_radom_key();
  encryped_radom_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.login.encryped_radom_key)
}
inline void login::set_encryped_radom_key(const char* value) {
  set_has_encryped_radom_key();
  encryped_radom_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.login.encryped_radom_key)
}
inline void login::set_encryped_radom_key(const void* value, size_t size) {
  set_has_encryped_radom_key();
  encryped_radom_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.login.encryped_radom_key)
}
inline ::std::string* login::mutable_encryped_radom_key() {
  set_has_encryped_radom_key();
  // @@protoc_insertion_point(field_mutable:proto.login.encryped_radom_key)
  return encryped_radom_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* login::release_encryped_radom_key() {
  clear_has_encryped_radom_key();
  return encryped_radom_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login::set_allocated_encryped_radom_key(::std::string* encryped_radom_key) {
  if (encryped_radom_key != NULL) {
    set_has_encryped_radom_key();
  } else {
    clear_has_encryped_radom_key();
  }
  encryped_radom_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encryped_radom_key);
  // @@protoc_insertion_point(field_set_allocated:proto.login.encryped_radom_key)
}

// optional string other_info = 3;
inline bool login::has_other_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void login::set_has_other_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void login::clear_has_other_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void login::clear_other_info() {
  other_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_other_info();
}
inline const ::std::string& login::other_info() const {
  // @@protoc_insertion_point(field_get:proto.login.other_info)
  return other_info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login::set_other_info(const ::std::string& value) {
  set_has_other_info();
  other_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.login.other_info)
}
inline void login::set_other_info(const char* value) {
  set_has_other_info();
  other_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.login.other_info)
}
inline void login::set_other_info(const char* value, size_t size) {
  set_has_other_info();
  other_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.login.other_info)
}
inline ::std::string* login::mutable_other_info() {
  set_has_other_info();
  // @@protoc_insertion_point(field_mutable:proto.login.other_info)
  return other_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* login::release_other_info() {
  clear_has_other_info();
  return other_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void login::set_allocated_other_info(::std::string* other_info) {
  if (other_info != NULL) {
    set_has_other_info();
  } else {
    clear_has_other_info();
  }
  other_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), other_info);
  // @@protoc_insertion_point(field_set_allocated:proto.login.other_info)
}

// -------------------------------------------------------------------

// login_result

// required .proto.login_result.login_result_code result = 1;
inline bool login_result::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void login_result::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void login_result::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void login_result::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::proto::login_result_login_result_code login_result::result() const {
  // @@protoc_insertion_point(field_get:proto.login_result.result)
  return static_cast< ::proto::login_result_login_result_code >(result_);
}
inline void login_result::set_result(::proto::login_result_login_result_code value) {
  assert(::proto::login_result_login_result_code_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.login_result.result)
}

// -------------------------------------------------------------------

// username_availability_check

// required string user_name = 1;
inline bool username_availability_check::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void username_availability_check::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void username_availability_check::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void username_availability_check::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_name();
}
inline const ::std::string& username_availability_check::user_name() const {
  // @@protoc_insertion_point(field_get:proto.username_availability_check.user_name)
  return user_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void username_availability_check::set_user_name(const ::std::string& value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.username_availability_check.user_name)
}
inline void username_availability_check::set_user_name(const char* value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.username_availability_check.user_name)
}
inline void username_availability_check::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.username_availability_check.user_name)
}
inline ::std::string* username_availability_check::mutable_user_name() {
  set_has_user_name();
  // @@protoc_insertion_point(field_mutable:proto.username_availability_check.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* username_availability_check::release_user_name() {
  clear_has_user_name();
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void username_availability_check::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    set_has_user_name();
  } else {
    clear_has_user_name();
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:proto.username_availability_check.user_name)
}

// -------------------------------------------------------------------

// username_availability_result

// required .proto.username_availability_result.username_availability_result_code result = 1;
inline bool username_availability_result::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void username_availability_result::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void username_availability_result::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void username_availability_result::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::proto::username_availability_result_username_availability_result_code username_availability_result::result() const {
  // @@protoc_insertion_point(field_get:proto.username_availability_result.result)
  return static_cast< ::proto::username_availability_result_username_availability_result_code >(result_);
}
inline void username_availability_result::set_result(::proto::username_availability_result_username_availability_result_code value) {
  assert(::proto::username_availability_result_username_availability_result_code_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.username_availability_result.result)
}

// -------------------------------------------------------------------

// user_register

// required string user_name = 1;
inline bool user_register::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_register::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_register::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_register::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_name();
}
inline const ::std::string& user_register::user_name() const {
  // @@protoc_insertion_point(field_get:proto.user_register.user_name)
  return user_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register::set_user_name(const ::std::string& value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.user_register.user_name)
}
inline void user_register::set_user_name(const char* value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.user_register.user_name)
}
inline void user_register::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.user_name)
}
inline ::std::string* user_register::mutable_user_name() {
  set_has_user_name();
  // @@protoc_insertion_point(field_mutable:proto.user_register.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_register::release_user_name() {
  clear_has_user_name();
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    set_has_user_name();
  } else {
    clear_has_user_name();
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.user_name)
}

// required bytes rsa_pubkey = 2;
inline bool user_register::has_rsa_pubkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_register::set_has_rsa_pubkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_register::clear_has_rsa_pubkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_register::clear_rsa_pubkey() {
  rsa_pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rsa_pubkey();
}
inline const ::std::string& user_register::rsa_pubkey() const {
  // @@protoc_insertion_point(field_get:proto.user_register.rsa_pubkey)
  return rsa_pubkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register::set_rsa_pubkey(const ::std::string& value) {
  set_has_rsa_pubkey();
  rsa_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.user_register.rsa_pubkey)
}
inline void user_register::set_rsa_pubkey(const char* value) {
  set_has_rsa_pubkey();
  rsa_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.user_register.rsa_pubkey)
}
inline void user_register::set_rsa_pubkey(const void* value, size_t size) {
  set_has_rsa_pubkey();
  rsa_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.rsa_pubkey)
}
inline ::std::string* user_register::mutable_rsa_pubkey() {
  set_has_rsa_pubkey();
  // @@protoc_insertion_point(field_mutable:proto.user_register.rsa_pubkey)
  return rsa_pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_register::release_rsa_pubkey() {
  clear_has_rsa_pubkey();
  return rsa_pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register::set_allocated_rsa_pubkey(::std::string* rsa_pubkey) {
  if (rsa_pubkey != NULL) {
    set_has_rsa_pubkey();
  } else {
    clear_has_rsa_pubkey();
  }
  rsa_pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rsa_pubkey);
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.rsa_pubkey)
}

// required bytes CSR = 3;
inline bool user_register::has_csr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_register::set_has_csr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_register::clear_has_csr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_register::clear_csr() {
  csr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_csr();
}
inline const ::std::string& user_register::csr() const {
  // @@protoc_insertion_point(field_get:proto.user_register.CSR)
  return csr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register::set_csr(const ::std::string& value) {
  set_has_csr();
  csr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.user_register.CSR)
}
inline void user_register::set_csr(const char* value) {
  set_has_csr();
  csr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.user_register.CSR)
}
inline void user_register::set_csr(const void* value, size_t size) {
  set_has_csr();
  csr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.CSR)
}
inline ::std::string* user_register::mutable_csr() {
  set_has_csr();
  // @@protoc_insertion_point(field_mutable:proto.user_register.CSR)
  return csr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_register::release_csr() {
  clear_has_csr();
  return csr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register::set_allocated_csr(::std::string* csr) {
  if (csr != NULL) {
    set_has_csr();
  } else {
    clear_has_csr();
  }
  csr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), csr);
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.CSR)
}

// optional string mail_address = 4;
inline bool user_register::has_mail_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_register::set_has_mail_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_register::clear_has_mail_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_register::clear_mail_address() {
  mail_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mail_address();
}
inline const ::std::string& user_register::mail_address() const {
  // @@protoc_insertion_point(field_get:proto.user_register.mail_address)
  return mail_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register::set_mail_address(const ::std::string& value) {
  set_has_mail_address();
  mail_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.user_register.mail_address)
}
inline void user_register::set_mail_address(const char* value) {
  set_has_mail_address();
  mail_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.user_register.mail_address)
}
inline void user_register::set_mail_address(const char* value, size_t size) {
  set_has_mail_address();
  mail_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.mail_address)
}
inline ::std::string* user_register::mutable_mail_address() {
  set_has_mail_address();
  // @@protoc_insertion_point(field_mutable:proto.user_register.mail_address)
  return mail_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_register::release_mail_address() {
  clear_has_mail_address();
  return mail_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register::set_allocated_mail_address(::std::string* mail_address) {
  if (mail_address != NULL) {
    set_has_mail_address();
  } else {
    clear_has_mail_address();
  }
  mail_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mail_address);
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.mail_address)
}

// optional string cell_phone = 5;
inline bool user_register::has_cell_phone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_register::set_has_cell_phone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_register::clear_has_cell_phone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_register::clear_cell_phone() {
  cell_phone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cell_phone();
}
inline const ::std::string& user_register::cell_phone() const {
  // @@protoc_insertion_point(field_get:proto.user_register.cell_phone)
  return cell_phone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register::set_cell_phone(const ::std::string& value) {
  set_has_cell_phone();
  cell_phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.user_register.cell_phone)
}
inline void user_register::set_cell_phone(const char* value) {
  set_has_cell_phone();
  cell_phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.user_register.cell_phone)
}
inline void user_register::set_cell_phone(const char* value, size_t size) {
  set_has_cell_phone();
  cell_phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.user_register.cell_phone)
}
inline ::std::string* user_register::mutable_cell_phone() {
  set_has_cell_phone();
  // @@protoc_insertion_point(field_mutable:proto.user_register.cell_phone)
  return cell_phone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_register::release_cell_phone() {
  clear_has_cell_phone();
  return cell_phone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register::set_allocated_cell_phone(::std::string* cell_phone) {
  if (cell_phone != NULL) {
    set_has_cell_phone();
  } else {
    clear_has_cell_phone();
  }
  cell_phone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cell_phone);
  // @@protoc_insertion_point(field_set_allocated:proto.user_register.cell_phone)
}

// -------------------------------------------------------------------

// user_register_result

// required .proto.user_register_result.user_register_result_code result = 1;
inline bool user_register_result::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_register_result::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_register_result::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_register_result::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::proto::user_register_result_user_register_result_code user_register_result::result() const {
  // @@protoc_insertion_point(field_get:proto.user_register_result.result)
  return static_cast< ::proto::user_register_result_user_register_result_code >(result_);
}
inline void user_register_result::set_result(::proto::user_register_result_user_register_result_code value) {
  assert(::proto::user_register_result_user_register_result_code_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:proto.user_register_result.result)
}

// optional bytes cert = 2;
inline bool user_register_result::has_cert() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_register_result::set_has_cert() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_register_result::clear_has_cert() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_register_result::clear_cert() {
  cert_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cert();
}
inline const ::std::string& user_register_result::cert() const {
  // @@protoc_insertion_point(field_get:proto.user_register_result.cert)
  return cert_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register_result::set_cert(const ::std::string& value) {
  set_has_cert();
  cert_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.user_register_result.cert)
}
inline void user_register_result::set_cert(const char* value) {
  set_has_cert();
  cert_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.user_register_result.cert)
}
inline void user_register_result::set_cert(const void* value, size_t size) {
  set_has_cert();
  cert_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.user_register_result.cert)
}
inline ::std::string* user_register_result::mutable_cert() {
  set_has_cert();
  // @@protoc_insertion_point(field_mutable:proto.user_register_result.cert)
  return cert_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_register_result::release_cert() {
  clear_has_cert();
  return cert_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_register_result::set_allocated_cert(::std::string* cert) {
  if (cert != NULL) {
    set_has_cert();
  } else {
    clear_has_cert();
  }
  cert_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cert);
  // @@protoc_insertion_point(field_set_allocated:proto.user_register_result.cert)
}

// -------------------------------------------------------------------

// user_cert_lost_request

// required string user_name = 1;
inline bool user_cert_lost_request::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_cert_lost_request::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_cert_lost_request::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_cert_lost_request::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_name();
}
inline const ::std::string& user_cert_lost_request::user_name() const {
  // @@protoc_insertion_point(field_get:proto.user_cert_lost_request.user_name)
  return user_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_cert_lost_request::set_user_name(const ::std::string& value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.user_cert_lost_request.user_name)
}
inline void user_cert_lost_request::set_user_name(const char* value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.user_cert_lost_request.user_name)
}
inline void user_cert_lost_request::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.user_cert_lost_request.user_name)
}
inline ::std::string* user_cert_lost_request::mutable_user_name() {
  set_has_user_name();
  // @@protoc_insertion_point(field_mutable:proto.user_cert_lost_request.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_cert_lost_request::release_user_name() {
  clear_has_user_name();
  return user_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_cert_lost_request::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    set_has_user_name();
  } else {
    clear_has_user_name();
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:proto.user_cert_lost_request.user_name)
}

// optional string mail_address = 3;
inline bool user_cert_lost_request::has_mail_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_cert_lost_request::set_has_mail_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_cert_lost_request::clear_has_mail_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_cert_lost_request::clear_mail_address() {
  mail_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mail_address();
}
inline const ::std::string& user_cert_lost_request::mail_address() const {
  // @@protoc_insertion_point(field_get:proto.user_cert_lost_request.mail_address)
  return mail_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_cert_lost_request::set_mail_address(const ::std::string& value) {
  set_has_mail_address();
  mail_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.user_cert_lost_request.mail_address)
}
inline void user_cert_lost_request::set_mail_address(const char* value) {
  set_has_mail_address();
  mail_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.user_cert_lost_request.mail_address)
}
inline void user_cert_lost_request::set_mail_address(const char* value, size_t size) {
  set_has_mail_address();
  mail_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.user_cert_lost_request.mail_address)
}
inline ::std::string* user_cert_lost_request::mutable_mail_address() {
  set_has_mail_address();
  // @@protoc_insertion_point(field_mutable:proto.user_cert_lost_request.mail_address)
  return mail_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_cert_lost_request::release_mail_address() {
  clear_has_mail_address();
  return mail_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_cert_lost_request::set_allocated_mail_address(::std::string* mail_address) {
  if (mail_address != NULL) {
    set_has_mail_address();
  } else {
    clear_has_mail_address();
  }
  mail_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mail_address);
  // @@protoc_insertion_point(field_set_allocated:proto.user_cert_lost_request.mail_address)
}

// optional string cell_phone = 4;
inline bool user_cert_lost_request::has_cell_phone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_cert_lost_request::set_has_cell_phone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_cert_lost_request::clear_has_cell_phone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_cert_lost_request::clear_cell_phone() {
  cell_phone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cell_phone();
}
inline const ::std::string& user_cert_lost_request::cell_phone() const {
  // @@protoc_insertion_point(field_get:proto.user_cert_lost_request.cell_phone)
  return cell_phone_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_cert_lost_request::set_cell_phone(const ::std::string& value) {
  set_has_cell_phone();
  cell_phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.user_cert_lost_request.cell_phone)
}
inline void user_cert_lost_request::set_cell_phone(const char* value) {
  set_has_cell_phone();
  cell_phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.user_cert_lost_request.cell_phone)
}
inline void user_cert_lost_request::set_cell_phone(const char* value, size_t size) {
  set_has_cell_phone();
  cell_phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.user_cert_lost_request.cell_phone)
}
inline ::std::string* user_cert_lost_request::mutable_cell_phone() {
  set_has_cell_phone();
  // @@protoc_insertion_point(field_mutable:proto.user_cert_lost_request.cell_phone)
  return cell_phone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_cert_lost_request::release_cell_phone() {
  clear_has_cell_phone();
  return cell_phone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_cert_lost_request::set_allocated_cell_phone(::std::string* cell_phone) {
  if (cell_phone != NULL) {
    set_has_cell_phone();
  } else {
    clear_has_cell_phone();
  }
  cell_phone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cell_phone);
  // @@protoc_insertion_point(field_set_allocated:proto.user_cert_lost_request.cell_phone)
}

// -------------------------------------------------------------------

// user_cert_lost_verify

// required string secret_code = 1;
inline bool user_cert_lost_verify::has_secret_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_cert_lost_verify::set_has_secret_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_cert_lost_verify::clear_has_secret_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_cert_lost_verify::clear_secret_code() {
  secret_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_secret_code();
}
inline const ::std::string& user_cert_lost_verify::secret_code() const {
  // @@protoc_insertion_point(field_get:proto.user_cert_lost_verify.secret_code)
  return secret_code_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_cert_lost_verify::set_secret_code(const ::std::string& value) {
  set_has_secret_code();
  secret_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.user_cert_lost_verify.secret_code)
}
inline void user_cert_lost_verify::set_secret_code(const char* value) {
  set_has_secret_code();
  secret_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.user_cert_lost_verify.secret_code)
}
inline void user_cert_lost_verify::set_secret_code(const char* value, size_t size) {
  set_has_secret_code();
  secret_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.user_cert_lost_verify.secret_code)
}
inline ::std::string* user_cert_lost_verify::mutable_secret_code() {
  set_has_secret_code();
  // @@protoc_insertion_point(field_mutable:proto.user_cert_lost_verify.secret_code)
  return secret_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* user_cert_lost_verify::release_secret_code() {
  clear_has_secret_code();
  return secret_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void user_cert_lost_verify::set_allocated_secret_code(::std::string* secret_code) {
  if (secret_code != NULL) {
    set_has_secret_code();
  } else {
    clear_has_secret_code();
  }
  secret_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret_code);
  // @@protoc_insertion_point(field_set_allocated:proto.user_cert_lost_verify.secret_code)
}

// -------------------------------------------------------------------

// buddy

// required .proto.av_address addr = 1;
inline bool buddy::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void buddy::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void buddy::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void buddy::clear_addr() {
  if (addr_ != NULL) addr_->::proto::av_address::Clear();
  clear_has_addr();
}
inline const ::proto::av_address& buddy::addr() const {
  // @@protoc_insertion_point(field_get:proto.buddy.addr)
  return addr_ != NULL ? *addr_ : *default_instance_->addr_;
}
inline ::proto::av_address* buddy::mutable_addr() {
  set_has_addr();
  if (addr_ == NULL) {
    addr_ = new ::proto::av_address;
  }
  // @@protoc_insertion_point(field_mutable:proto.buddy.addr)
  return addr_;
}
inline ::proto::av_address* buddy::release_addr() {
  clear_has_addr();
  ::proto::av_address* temp = addr_;
  addr_ = NULL;
  return temp;
}
inline void buddy::set_allocated_addr(::proto::av_address* addr) {
  delete addr_;
  addr_ = addr;
  if (addr) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  // @@protoc_insertion_point(field_set_allocated:proto.buddy.addr)
}

// optional string nick = 2;
inline bool buddy::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buddy::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buddy::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buddy::clear_nick() {
  nick_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nick();
}
inline const ::std::string& buddy::nick() const {
  // @@protoc_insertion_point(field_get:proto.buddy.nick)
  return nick_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void buddy::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.buddy.nick)
}
inline void buddy::set_nick(const char* value) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.buddy.nick)
}
inline void buddy::set_nick(const char* value, size_t size) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.buddy.nick)
}
inline ::std::string* buddy::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:proto.buddy.nick)
  return nick_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* buddy::release_nick() {
  clear_has_nick();
  return nick_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void buddy::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick);
  // @@protoc_insertion_point(field_set_allocated:proto.buddy.nick)
}

// repeated string labels = 3;
inline int buddy::labels_size() const {
  return labels_.size();
}
inline void buddy::clear_labels() {
  labels_.Clear();
}
inline const ::std::string& buddy::labels(int index) const {
  // @@protoc_insertion_point(field_get:proto.buddy.labels)
  return labels_.Get(index);
}
inline ::std::string* buddy::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:proto.buddy.labels)
  return labels_.Mutable(index);
}
inline void buddy::set_labels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:proto.buddy.labels)
  labels_.Mutable(index)->assign(value);
}
inline void buddy::set_labels(int index, const char* value) {
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:proto.buddy.labels)
}
inline void buddy::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:proto.buddy.labels)
}
inline ::std::string* buddy::add_labels() {
  return labels_.Add();
}
inline void buddy::add_labels(const ::std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:proto.buddy.labels)
}
inline void buddy::add_labels(const char* value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:proto.buddy.labels)
}
inline void buddy::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:proto.buddy.labels)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
buddy::labels() const {
  // @@protoc_insertion_point(field_list:proto.buddy.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
buddy::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:proto.buddy.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// buddy_list

// repeated .proto.buddy buddies = 1;
inline int buddy_list::buddies_size() const {
  return buddies_.size();
}
inline void buddy_list::clear_buddies() {
  buddies_.Clear();
}
inline const ::proto::buddy& buddy_list::buddies(int index) const {
  // @@protoc_insertion_point(field_get:proto.buddy_list.buddies)
  return buddies_.Get(index);
}
inline ::proto::buddy* buddy_list::mutable_buddies(int index) {
  // @@protoc_insertion_point(field_mutable:proto.buddy_list.buddies)
  return buddies_.Mutable(index);
}
inline ::proto::buddy* buddy_list::add_buddies() {
  // @@protoc_insertion_point(field_add:proto.buddy_list.buddies)
  return buddies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::buddy >&
buddy_list::buddies() const {
  // @@protoc_insertion_point(field_list:proto.buddy_list.buddies)
  return buddies_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::buddy >*
buddy_list::mutable_buddies() {
  // @@protoc_insertion_point(field_mutable_list:proto.buddy_list.buddies)
  return &buddies_;
}

// -------------------------------------------------------------------

// request_buddy_list


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::login_result_login_result_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::login_result_login_result_code>() {
  return ::proto::login_result_login_result_code_descriptor();
}
template <> struct is_proto_enum< ::proto::username_availability_result_username_availability_result_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::username_availability_result_username_availability_result_code>() {
  return ::proto::username_availability_result_username_availability_result_code_descriptor();
}
template <> struct is_proto_enum< ::proto::user_register_result_user_register_result_code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::user_register_result_user_register_result_code>() {
  return ::proto::user_register_result_user_register_result_code_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_2eproto__INCLUDED
