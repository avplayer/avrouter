// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.proto

#ifndef PROTOBUF_im_2eproto__INCLUDED
#define PROTOBUF_im_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "address.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_im_2eproto();
void protobuf_AssignDesc_im_2eproto();
void protobuf_ShutdownFile_im_2eproto();

class text_message;
class img_message;
class emoji_message;
class symmetry_encryption_key_distribution;
class avim_message;
class message_packet;
class group_security_key;
class control_message;
class control_message_buddy_state_notify;

enum symmetry_encryption_key_distribution_EncryptionType {
  symmetry_encryption_key_distribution_EncryptionType_AES = 0,
  symmetry_encryption_key_distribution_EncryptionType_DES = 1,
  symmetry_encryption_key_distribution_EncryptionType_BlowFish = 2,
  symmetry_encryption_key_distribution_EncryptionType_TwoFish = 3,
  symmetry_encryption_key_distribution_EncryptionType_Camellia = 4,
  symmetry_encryption_key_distribution_EncryptionType_DES3_EDE = 5
};
bool symmetry_encryption_key_distribution_EncryptionType_IsValid(int value);
const symmetry_encryption_key_distribution_EncryptionType symmetry_encryption_key_distribution_EncryptionType_EncryptionType_MIN = symmetry_encryption_key_distribution_EncryptionType_AES;
const symmetry_encryption_key_distribution_EncryptionType symmetry_encryption_key_distribution_EncryptionType_EncryptionType_MAX = symmetry_encryption_key_distribution_EncryptionType_DES3_EDE;
const int symmetry_encryption_key_distribution_EncryptionType_EncryptionType_ARRAYSIZE = symmetry_encryption_key_distribution_EncryptionType_EncryptionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* symmetry_encryption_key_distribution_EncryptionType_descriptor();
inline const ::std::string& symmetry_encryption_key_distribution_EncryptionType_Name(symmetry_encryption_key_distribution_EncryptionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    symmetry_encryption_key_distribution_EncryptionType_descriptor(), value);
}
inline bool symmetry_encryption_key_distribution_EncryptionType_Parse(
    const ::std::string& name, symmetry_encryption_key_distribution_EncryptionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<symmetry_encryption_key_distribution_EncryptionType>(
    symmetry_encryption_key_distribution_EncryptionType_descriptor(), name, value);
}
enum control_message_buddy_state {
  control_message_buddy_state_ONLINE = 0,
  control_message_buddy_state_OFFLINE = 1,
  control_message_buddy_state_HIDDING = 2
};
bool control_message_buddy_state_IsValid(int value);
const control_message_buddy_state control_message_buddy_state_buddy_state_MIN = control_message_buddy_state_ONLINE;
const control_message_buddy_state control_message_buddy_state_buddy_state_MAX = control_message_buddy_state_HIDDING;
const int control_message_buddy_state_buddy_state_ARRAYSIZE = control_message_buddy_state_buddy_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* control_message_buddy_state_descriptor();
inline const ::std::string& control_message_buddy_state_Name(control_message_buddy_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    control_message_buddy_state_descriptor(), value);
}
inline bool control_message_buddy_state_Parse(
    const ::std::string& name, control_message_buddy_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<control_message_buddy_state>(
    control_message_buddy_state_descriptor(), name, value);
}
// ===================================================================

class text_message : public ::google::protobuf::Message {
 public:
  text_message();
  virtual ~text_message();

  text_message(const text_message& from);

  inline text_message& operator=(const text_message& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline text_message& operator=(text_message&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  text_message(text_message&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const text_message& default_instance();

  void Swap(text_message* other);

  // implements Message ----------------------------------------------

  text_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const text_message& from);
  void MergeFrom(const text_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string fontname = 2;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontnameFieldNumber = 2;
  inline const ::std::string& fontname() const;
  inline void set_fontname(const ::std::string& value);
  inline void set_fontname(const char* value);
  inline void set_fontname(const char* value, size_t size);
  inline ::std::string* mutable_fontname();
  inline ::std::string* release_fontname();
  inline void set_allocated_fontname(::std::string* fontname);

  // optional float fontsie = 3;
  inline bool has_fontsie() const;
  inline void clear_fontsie();
  static const int kFontsieFieldNumber = 3;
  inline float fontsie() const;
  inline void set_fontsie(float value);

  // optional string hlink = 4;
  inline bool has_hlink() const;
  inline void clear_hlink();
  static const int kHlinkFieldNumber = 4;
  inline const ::std::string& hlink() const;
  inline void set_hlink(const ::std::string& value);
  inline void set_hlink(const char* value);
  inline void set_hlink(const char* value, size_t size);
  inline ::std::string* mutable_hlink();
  inline ::std::string* release_hlink();
  inline void set_allocated_hlink(::std::string* hlink);

  // @@protoc_insertion_point(class_scope:message.text_message)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_fontname();
  inline void clear_has_fontname();
  inline void set_has_fontsie();
  inline void clear_has_fontsie();
  inline void set_has_hlink();
  inline void clear_has_hlink();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* text_;
  ::std::string* fontname_;
  ::std::string* hlink_;
  float fontsie_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static text_message* default_instance_;
};
// -------------------------------------------------------------------

class img_message : public ::google::protobuf::Message {
 public:
  img_message();
  virtual ~img_message();

  img_message(const img_message& from);

  inline img_message& operator=(const img_message& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline img_message& operator=(img_message&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  img_message(img_message&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const img_message& default_instance();

  void Swap(img_message* other);

  // implements Message ----------------------------------------------

  img_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const img_message& from);
  void MergeFrom(const img_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const void* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional bytes image_digest = 2;
  inline bool has_image_digest() const;
  inline void clear_image_digest();
  static const int kImageDigestFieldNumber = 2;
  inline const ::std::string& image_digest() const;
  inline void set_image_digest(const ::std::string& value);
  inline void set_image_digest(const char* value);
  inline void set_image_digest(const void* value, size_t size);
  inline ::std::string* mutable_image_digest();
  inline ::std::string* release_image_digest();
  inline void set_allocated_image_digest(::std::string* image_digest);

  // optional bool animated = 3;
  inline bool has_animated() const;
  inline void clear_animated();
  static const int kAnimatedFieldNumber = 3;
  inline bool animated() const;
  inline void set_animated(bool value);

  // optional string hlink = 4;
  inline bool has_hlink() const;
  inline void clear_hlink();
  static const int kHlinkFieldNumber = 4;
  inline const ::std::string& hlink() const;
  inline void set_hlink(const ::std::string& value);
  inline void set_hlink(const char* value);
  inline void set_hlink(const char* value, size_t size);
  inline ::std::string* mutable_hlink();
  inline ::std::string* release_hlink();
  inline void set_allocated_hlink(::std::string* hlink);

  // @@protoc_insertion_point(class_scope:message.img_message)
 private:
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_image_digest();
  inline void clear_has_image_digest();
  inline void set_has_animated();
  inline void clear_has_animated();
  inline void set_has_hlink();
  inline void clear_has_hlink();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* image_;
  ::std::string* image_digest_;
  ::std::string* hlink_;
  bool animated_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static img_message* default_instance_;
};
// -------------------------------------------------------------------

class emoji_message : public ::google::protobuf::Message {
 public:
  emoji_message();
  virtual ~emoji_message();

  emoji_message(const emoji_message& from);

  inline emoji_message& operator=(const emoji_message& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline emoji_message& operator=(emoji_message&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  emoji_message(emoji_message&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const emoji_message& default_instance();

  void Swap(emoji_message* other);

  // implements Message ----------------------------------------------

  emoji_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const emoji_message& from);
  void MergeFrom(const emoji_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string emoji = 1;
  inline bool has_emoji() const;
  inline void clear_emoji();
  static const int kEmojiFieldNumber = 1;
  inline const ::std::string& emoji() const;
  inline void set_emoji(const ::std::string& value);
  inline void set_emoji(const char* value);
  inline void set_emoji(const char* value, size_t size);
  inline ::std::string* mutable_emoji();
  inline ::std::string* release_emoji();
  inline void set_allocated_emoji(::std::string* emoji);

  // optional string theme = 2;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 2;
  inline const ::std::string& theme() const;
  inline void set_theme(const ::std::string& value);
  inline void set_theme(const char* value);
  inline void set_theme(const char* value, size_t size);
  inline ::std::string* mutable_theme();
  inline ::std::string* release_theme();
  inline void set_allocated_theme(::std::string* theme);

  // optional bytes custom_image = 3;
  inline bool has_custom_image() const;
  inline void clear_custom_image();
  static const int kCustomImageFieldNumber = 3;
  inline const ::std::string& custom_image() const;
  inline void set_custom_image(const ::std::string& value);
  inline void set_custom_image(const char* value);
  inline void set_custom_image(const void* value, size_t size);
  inline ::std::string* mutable_custom_image();
  inline ::std::string* release_custom_image();
  inline void set_allocated_custom_image(::std::string* custom_image);

  // @@protoc_insertion_point(class_scope:message.emoji_message)
 private:
  inline void set_has_emoji();
  inline void clear_has_emoji();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_custom_image();
  inline void clear_has_custom_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* emoji_;
  ::std::string* theme_;
  ::std::string* custom_image_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static emoji_message* default_instance_;
};
// -------------------------------------------------------------------

class symmetry_encryption_key_distribution : public ::google::protobuf::Message {
 public:
  symmetry_encryption_key_distribution();
  virtual ~symmetry_encryption_key_distribution();

  symmetry_encryption_key_distribution(const symmetry_encryption_key_distribution& from);

  inline symmetry_encryption_key_distribution& operator=(const symmetry_encryption_key_distribution& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline symmetry_encryption_key_distribution& operator=(symmetry_encryption_key_distribution&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  symmetry_encryption_key_distribution(symmetry_encryption_key_distribution&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const symmetry_encryption_key_distribution& default_instance();

  void Swap(symmetry_encryption_key_distribution* other);

  // implements Message ----------------------------------------------

  symmetry_encryption_key_distribution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const symmetry_encryption_key_distribution& from);
  void MergeFrom(const symmetry_encryption_key_distribution& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef symmetry_encryption_key_distribution_EncryptionType EncryptionType;
  static const EncryptionType AES = symmetry_encryption_key_distribution_EncryptionType_AES;
  static const EncryptionType DES = symmetry_encryption_key_distribution_EncryptionType_DES;
  static const EncryptionType BlowFish = symmetry_encryption_key_distribution_EncryptionType_BlowFish;
  static const EncryptionType TwoFish = symmetry_encryption_key_distribution_EncryptionType_TwoFish;
  static const EncryptionType Camellia = symmetry_encryption_key_distribution_EncryptionType_Camellia;
  static const EncryptionType DES3_EDE = symmetry_encryption_key_distribution_EncryptionType_DES3_EDE;
  static inline bool EncryptionType_IsValid(int value) {
    return symmetry_encryption_key_distribution_EncryptionType_IsValid(value);
  }
  static const EncryptionType EncryptionType_MIN =
    symmetry_encryption_key_distribution_EncryptionType_EncryptionType_MIN;
  static const EncryptionType EncryptionType_MAX =
    symmetry_encryption_key_distribution_EncryptionType_EncryptionType_MAX;
  static const int EncryptionType_ARRAYSIZE =
    symmetry_encryption_key_distribution_EncryptionType_EncryptionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EncryptionType_descriptor() {
    return symmetry_encryption_key_distribution_EncryptionType_descriptor();
  }
  static inline const ::std::string& EncryptionType_Name(EncryptionType value) {
    return symmetry_encryption_key_distribution_EncryptionType_Name(value);
  }
  static inline bool EncryptionType_Parse(const ::std::string& name,
      EncryptionType* value) {
    return symmetry_encryption_key_distribution_EncryptionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .message.symmetry_encryption_key_distribution.EncryptionType keytype = 1;
  inline bool has_keytype() const;
  inline void clear_keytype();
  static const int kKeytypeFieldNumber = 1;
  inline ::message::symmetry_encryption_key_distribution_EncryptionType keytype() const;
  inline void set_keytype(::message::symmetry_encryption_key_distribution_EncryptionType value);

  // required bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:message.symmetry_encryption_key_distribution)
 private:
  inline void set_has_keytype();
  inline void clear_has_keytype();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  int keytype_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static symmetry_encryption_key_distribution* default_instance_;
};
// -------------------------------------------------------------------

class avim_message : public ::google::protobuf::Message {
 public:
  avim_message();
  virtual ~avim_message();

  avim_message(const avim_message& from);

  inline avim_message& operator=(const avim_message& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline avim_message& operator=(avim_message&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  avim_message(avim_message&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const avim_message& default_instance();

  void Swap(avim_message* other);

  // implements Message ----------------------------------------------

  avim_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const avim_message& from);
  void MergeFrom(const avim_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .message.text_message item_text = 1;
  inline bool has_item_text() const;
  inline void clear_item_text();
  static const int kItemTextFieldNumber = 1;
  inline const ::message::text_message& item_text() const;
  inline ::message::text_message* mutable_item_text();
  inline ::message::text_message* release_item_text();
  inline void set_allocated_item_text(::message::text_message* item_text);

  // optional .message.img_message item_image = 2;
  inline bool has_item_image() const;
  inline void clear_item_image();
  static const int kItemImageFieldNumber = 2;
  inline const ::message::img_message& item_image() const;
  inline ::message::img_message* mutable_item_image();
  inline ::message::img_message* release_item_image();
  inline void set_allocated_item_image(::message::img_message* item_image);

  // optional .message.emoji_message item_emoji = 3;
  inline bool has_item_emoji() const;
  inline void clear_item_emoji();
  static const int kItemEmojiFieldNumber = 3;
  inline const ::message::emoji_message& item_emoji() const;
  inline ::message::emoji_message* mutable_item_emoji();
  inline ::message::emoji_message* release_item_emoji();
  inline void set_allocated_item_emoji(::message::emoji_message* item_emoji);

  // optional .message.symmetry_encryption_key_distribution item_key = 20;
  inline bool has_item_key() const;
  inline void clear_item_key();
  static const int kItemKeyFieldNumber = 20;
  inline const ::message::symmetry_encryption_key_distribution& item_key() const;
  inline ::message::symmetry_encryption_key_distribution* mutable_item_key();
  inline ::message::symmetry_encryption_key_distribution* release_item_key();
  inline void set_allocated_item_key(::message::symmetry_encryption_key_distribution* item_key);

  // @@protoc_insertion_point(class_scope:message.avim_message)
 private:
  inline void set_has_item_text();
  inline void clear_has_item_text();
  inline void set_has_item_image();
  inline void clear_has_item_image();
  inline void set_has_item_emoji();
  inline void clear_has_item_emoji();
  inline void set_has_item_key();
  inline void clear_has_item_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::message::text_message* item_text_;
  ::message::img_message* item_image_;
  ::message::emoji_message* item_emoji_;
  ::message::symmetry_encryption_key_distribution* item_key_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static avim_message* default_instance_;
};
// -------------------------------------------------------------------

class message_packet : public ::google::protobuf::Message {
 public:
  message_packet();
  virtual ~message_packet();

  message_packet(const message_packet& from);

  inline message_packet& operator=(const message_packet& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline message_packet& operator=(message_packet&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  message_packet(message_packet&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_packet& default_instance();

  void Swap(message_packet* other);

  // implements Message ----------------------------------------------

  message_packet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const message_packet& from);
  void MergeFrom(const message_packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .message.avim_message avim = 1;
  inline int avim_size() const;
  inline void clear_avim();
  static const int kAvimFieldNumber = 1;
  inline const ::message::avim_message& avim(int index) const;
  inline ::message::avim_message* mutable_avim(int index);
  inline ::message::avim_message* add_avim();
  inline const ::google::protobuf::RepeatedPtrField< ::message::avim_message >&
      avim() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::avim_message >*
      mutable_avim();

  // optional uint64 serial = 2;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 2;
  inline ::google::protobuf::uint64 serial() const;
  inline void set_serial(::google::protobuf::uint64 value);

  // optional .proto.av_address sender = 3;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 3;
  inline const ::proto::av_address& sender() const;
  inline ::proto::av_address* mutable_sender();
  inline ::proto::av_address* release_sender();
  inline void set_allocated_sender(::proto::av_address* sender);

  // @@protoc_insertion_point(class_scope:message.message_packet)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_sender();
  inline void clear_has_sender();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::message::avim_message > avim_;
  ::google::protobuf::uint64 serial_;
  ::proto::av_address* sender_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static message_packet* default_instance_;
};
// -------------------------------------------------------------------

class group_security_key : public ::google::protobuf::Message {
 public:
  group_security_key();
  virtual ~group_security_key();

  group_security_key(const group_security_key& from);

  inline group_security_key& operator=(const group_security_key& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline group_security_key& operator=(group_security_key&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  group_security_key(group_security_key&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const group_security_key& default_instance();

  void Swap(group_security_key* other);

  // implements Message ----------------------------------------------

  group_security_key* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const group_security_key& from);
  void MergeFrom(const group_security_key& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bytes prev_key = 2;
  inline bool has_prev_key() const;
  inline void clear_prev_key();
  static const int kPrevKeyFieldNumber = 2;
  inline const ::std::string& prev_key() const;
  inline void set_prev_key(const ::std::string& value);
  inline void set_prev_key(const char* value);
  inline void set_prev_key(const void* value, size_t size);
  inline ::std::string* mutable_prev_key();
  inline ::std::string* release_prev_key();
  inline void set_allocated_prev_key(::std::string* prev_key);

  // required uint64 valid_until = 3;
  inline bool has_valid_until() const;
  inline void clear_valid_until();
  static const int kValidUntilFieldNumber = 3;
  inline ::google::protobuf::uint64 valid_until() const;
  inline void set_valid_until(::google::protobuf::uint64 value);

  // required uint32 key_id = 4;
  inline bool has_key_id() const;
  inline void clear_key_id();
  static const int kKeyIdFieldNumber = 4;
  inline ::google::protobuf::uint32 key_id() const;
  inline void set_key_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message.group_security_key)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_prev_key();
  inline void clear_has_prev_key();
  inline void set_has_valid_until();
  inline void clear_has_valid_until();
  inline void set_has_key_id();
  inline void clear_has_key_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* prev_key_;
  ::google::protobuf::uint64 valid_until_;
  ::google::protobuf::uint32 key_id_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static group_security_key* default_instance_;
};
// -------------------------------------------------------------------

class control_message_buddy_state_notify : public ::google::protobuf::Message {
 public:
  control_message_buddy_state_notify();
  virtual ~control_message_buddy_state_notify();

  control_message_buddy_state_notify(const control_message_buddy_state_notify& from);

  inline control_message_buddy_state_notify& operator=(const control_message_buddy_state_notify& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline control_message_buddy_state_notify& operator=(control_message_buddy_state_notify&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  control_message_buddy_state_notify(control_message_buddy_state_notify&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const control_message_buddy_state_notify& default_instance();

  void Swap(control_message_buddy_state_notify* other);

  // implements Message ----------------------------------------------

  control_message_buddy_state_notify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const control_message_buddy_state_notify& from);
  void MergeFrom(const control_message_buddy_state_notify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .proto.av_address who = 1;
  inline bool has_who() const;
  inline void clear_who();
  static const int kWhoFieldNumber = 1;
  inline const ::proto::av_address& who() const;
  inline ::proto::av_address* mutable_who();
  inline ::proto::av_address* release_who();
  inline void set_allocated_who(::proto::av_address* who);

  // required .message.control_message.buddy_state state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::message::control_message_buddy_state state() const;
  inline void set_state(::message::control_message_buddy_state value);

  // @@protoc_insertion_point(class_scope:message.control_message.buddy_state_notify)
 private:
  inline void set_has_who();
  inline void clear_has_who();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::av_address* who_;
  int state_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static control_message_buddy_state_notify* default_instance_;
};
// -------------------------------------------------------------------

class control_message : public ::google::protobuf::Message {
 public:
  control_message();
  virtual ~control_message();

  control_message(const control_message& from);

  inline control_message& operator=(const control_message& from) {
    CopyFrom(from);
    return *this;
  }

  #if __cplusplus >= 201103L || _MSC_VER >= 1600
  inline control_message& operator=(control_message&& from) {
    if (&from != this) {
      Clear();
      Swap(&from);
    }
    return *this;
  }

  control_message(control_message&& from);
  #endif

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const control_message& default_instance();

  void Swap(control_message* other);

  // implements Message ----------------------------------------------

  control_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const control_message& from);
  void MergeFrom(const control_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef control_message_buddy_state_notify buddy_state_notify;

  typedef control_message_buddy_state buddy_state;
  static const buddy_state ONLINE = control_message_buddy_state_ONLINE;
  static const buddy_state OFFLINE = control_message_buddy_state_OFFLINE;
  static const buddy_state HIDDING = control_message_buddy_state_HIDDING;
  static inline bool buddy_state_IsValid(int value) {
    return control_message_buddy_state_IsValid(value);
  }
  static const buddy_state buddy_state_MIN =
    control_message_buddy_state_buddy_state_MIN;
  static const buddy_state buddy_state_MAX =
    control_message_buddy_state_buddy_state_MAX;
  static const int buddy_state_ARRAYSIZE =
    control_message_buddy_state_buddy_state_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  buddy_state_descriptor() {
    return control_message_buddy_state_descriptor();
  }
  static inline const ::std::string& buddy_state_Name(buddy_state value) {
    return control_message_buddy_state_Name(value);
  }
  static inline bool buddy_state_Parse(const ::std::string& name,
      buddy_state* value) {
    return control_message_buddy_state_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.av_address sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::proto::av_address& sender() const;
  inline ::proto::av_address* mutable_sender();
  inline ::proto::av_address* release_sender();
  inline void set_allocated_sender(::proto::av_address* sender);

  // optional .message.group_security_key group_key = 2;
  inline bool has_group_key() const;
  inline void clear_group_key();
  static const int kGroupKeyFieldNumber = 2;
  inline const ::message::group_security_key& group_key() const;
  inline ::message::group_security_key* mutable_group_key();
  inline ::message::group_security_key* release_group_key();
  inline void set_allocated_group_key(::message::group_security_key* group_key);

  // repeated .proto.av_address new_bie = 3;
  inline int new_bie_size() const;
  inline void clear_new_bie();
  static const int kNewBieFieldNumber = 3;
  inline const ::proto::av_address& new_bie(int index) const;
  inline ::proto::av_address* mutable_new_bie(int index);
  inline ::proto::av_address* add_new_bie();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::av_address >&
      new_bie() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::av_address >*
      mutable_new_bie();

  // repeated .proto.av_address gone_bie = 4;
  inline int gone_bie_size() const;
  inline void clear_gone_bie();
  static const int kGoneBieFieldNumber = 4;
  inline const ::proto::av_address& gone_bie(int index) const;
  inline ::proto::av_address* mutable_gone_bie(int index);
  inline ::proto::av_address* add_gone_bie();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::av_address >&
      gone_bie() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::av_address >*
      mutable_gone_bie();

  // repeated .message.control_message.buddy_state_notify buddy_status = 5;
  inline int buddy_status_size() const;
  inline void clear_buddy_status();
  static const int kBuddyStatusFieldNumber = 5;
  inline const ::message::control_message_buddy_state_notify& buddy_status(int index) const;
  inline ::message::control_message_buddy_state_notify* mutable_buddy_status(int index);
  inline ::message::control_message_buddy_state_notify* add_buddy_status();
  inline const ::google::protobuf::RepeatedPtrField< ::message::control_message_buddy_state_notify >&
      buddy_status() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::control_message_buddy_state_notify >*
      mutable_buddy_status();

  // @@protoc_insertion_point(class_scope:message.control_message)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_group_key();
  inline void clear_has_group_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::proto::av_address* sender_;
  ::message::group_security_key* group_key_;
  ::google::protobuf::RepeatedPtrField< ::proto::av_address > new_bie_;
  ::google::protobuf::RepeatedPtrField< ::proto::av_address > gone_bie_;
  ::google::protobuf::RepeatedPtrField< ::message::control_message_buddy_state_notify > buddy_status_;
  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static control_message* default_instance_;
};
// ===================================================================


// ===================================================================

// text_message

// required string text = 1;
inline bool text_message::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void text_message::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void text_message::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void text_message::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& text_message::text() const {
  // @@protoc_insertion_point(field_get:message.text_message.text)
  return *text_;
}
inline void text_message::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set:message.text_message.text)
}
inline void text_message::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.text_message.text)
}
inline void text_message::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.text_message.text)
}
inline ::std::string* text_message::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.text_message.text)
  return text_;
}
inline ::std::string* text_message::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void text_message::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.text_message.text)
}

// optional string fontname = 2;
inline bool text_message::has_fontname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void text_message::set_has_fontname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void text_message::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void text_message::clear_fontname() {
  if (fontname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_->clear();
  }
  clear_has_fontname();
}
inline const ::std::string& text_message::fontname() const {
  // @@protoc_insertion_point(field_get:message.text_message.fontname)
  return *fontname_;
}
inline void text_message::set_fontname(const ::std::string& value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
  // @@protoc_insertion_point(field_set:message.text_message.fontname)
}
inline void text_message::set_fontname(const char* value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.text_message.fontname)
}
inline void text_message::set_fontname(const char* value, size_t size) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.text_message.fontname)
}
inline ::std::string* text_message::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fontname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.text_message.fontname)
  return fontname_;
}
inline ::std::string* text_message::release_fontname() {
  clear_has_fontname();
  if (fontname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fontname_;
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void text_message::set_allocated_fontname(::std::string* fontname) {
  if (fontname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fontname_;
  }
  if (fontname) {
    set_has_fontname();
    fontname_ = fontname;
  } else {
    clear_has_fontname();
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.text_message.fontname)
}

// optional float fontsie = 3;
inline bool text_message::has_fontsie() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void text_message::set_has_fontsie() {
  _has_bits_[0] |= 0x00000004u;
}
inline void text_message::clear_has_fontsie() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void text_message::clear_fontsie() {
  fontsie_ = 0;
  clear_has_fontsie();
}
inline float text_message::fontsie() const {
  // @@protoc_insertion_point(field_get:message.text_message.fontsie)
  return fontsie_;
}
inline void text_message::set_fontsie(float value) {
  set_has_fontsie();
  fontsie_ = value;
  // @@protoc_insertion_point(field_set:message.text_message.fontsie)
}

// optional string hlink = 4;
inline bool text_message::has_hlink() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void text_message::set_has_hlink() {
  _has_bits_[0] |= 0x00000008u;
}
inline void text_message::clear_has_hlink() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void text_message::clear_hlink() {
  if (hlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_->clear();
  }
  clear_has_hlink();
}
inline const ::std::string& text_message::hlink() const {
  // @@protoc_insertion_point(field_get:message.text_message.hlink)
  return *hlink_;
}
inline void text_message::set_hlink(const ::std::string& value) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(value);
  // @@protoc_insertion_point(field_set:message.text_message.hlink)
}
inline void text_message::set_hlink(const char* value) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.text_message.hlink)
}
inline void text_message::set_hlink(const char* value, size_t size) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.text_message.hlink)
}
inline ::std::string* text_message::mutable_hlink() {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.text_message.hlink)
  return hlink_;
}
inline ::std::string* text_message::release_hlink() {
  clear_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hlink_;
    hlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void text_message::set_allocated_hlink(::std::string* hlink) {
  if (hlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hlink_;
  }
  if (hlink) {
    set_has_hlink();
    hlink_ = hlink;
  } else {
    clear_has_hlink();
    hlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.text_message.hlink)
}

// -------------------------------------------------------------------

// img_message

// required bytes image = 1;
inline bool img_message::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void img_message::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void img_message::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void img_message::clear_image() {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& img_message::image() const {
  // @@protoc_insertion_point(field_get:message.img_message.image)
  return *image_;
}
inline void img_message::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(value);
  // @@protoc_insertion_point(field_set:message.img_message.image)
}
inline void img_message::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.img_message.image)
}
inline void img_message::set_image(const void* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.img_message.image)
}
inline ::std::string* img_message::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.img_message.image)
  return image_;
}
inline ::std::string* img_message::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void img_message::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.img_message.image)
}

// optional bytes image_digest = 2;
inline bool img_message::has_image_digest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void img_message::set_has_image_digest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void img_message::clear_has_image_digest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void img_message::clear_image_digest() {
  if (image_digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_digest_->clear();
  }
  clear_has_image_digest();
}
inline const ::std::string& img_message::image_digest() const {
  // @@protoc_insertion_point(field_get:message.img_message.image_digest)
  return *image_digest_;
}
inline void img_message::set_image_digest(const ::std::string& value) {
  set_has_image_digest();
  if (image_digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_digest_ = new ::std::string;
  }
  image_digest_->assign(value);
  // @@protoc_insertion_point(field_set:message.img_message.image_digest)
}
inline void img_message::set_image_digest(const char* value) {
  set_has_image_digest();
  if (image_digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_digest_ = new ::std::string;
  }
  image_digest_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.img_message.image_digest)
}
inline void img_message::set_image_digest(const void* value, size_t size) {
  set_has_image_digest();
  if (image_digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_digest_ = new ::std::string;
  }
  image_digest_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.img_message.image_digest)
}
inline ::std::string* img_message::mutable_image_digest() {
  set_has_image_digest();
  if (image_digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    image_digest_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.img_message.image_digest)
  return image_digest_;
}
inline ::std::string* img_message::release_image_digest() {
  clear_has_image_digest();
  if (image_digest_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = image_digest_;
    image_digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void img_message::set_allocated_image_digest(::std::string* image_digest) {
  if (image_digest_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete image_digest_;
  }
  if (image_digest) {
    set_has_image_digest();
    image_digest_ = image_digest;
  } else {
    clear_has_image_digest();
    image_digest_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.img_message.image_digest)
}

// optional bool animated = 3;
inline bool img_message::has_animated() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void img_message::set_has_animated() {
  _has_bits_[0] |= 0x00000004u;
}
inline void img_message::clear_has_animated() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void img_message::clear_animated() {
  animated_ = false;
  clear_has_animated();
}
inline bool img_message::animated() const {
  // @@protoc_insertion_point(field_get:message.img_message.animated)
  return animated_;
}
inline void img_message::set_animated(bool value) {
  set_has_animated();
  animated_ = value;
  // @@protoc_insertion_point(field_set:message.img_message.animated)
}

// optional string hlink = 4;
inline bool img_message::has_hlink() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void img_message::set_has_hlink() {
  _has_bits_[0] |= 0x00000008u;
}
inline void img_message::clear_has_hlink() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void img_message::clear_hlink() {
  if (hlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_->clear();
  }
  clear_has_hlink();
}
inline const ::std::string& img_message::hlink() const {
  // @@protoc_insertion_point(field_get:message.img_message.hlink)
  return *hlink_;
}
inline void img_message::set_hlink(const ::std::string& value) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(value);
  // @@protoc_insertion_point(field_set:message.img_message.hlink)
}
inline void img_message::set_hlink(const char* value) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.img_message.hlink)
}
inline void img_message::set_hlink(const char* value, size_t size) {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  hlink_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.img_message.hlink)
}
inline ::std::string* img_message::mutable_hlink() {
  set_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hlink_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.img_message.hlink)
  return hlink_;
}
inline ::std::string* img_message::release_hlink() {
  clear_has_hlink();
  if (hlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hlink_;
    hlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void img_message::set_allocated_hlink(::std::string* hlink) {
  if (hlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hlink_;
  }
  if (hlink) {
    set_has_hlink();
    hlink_ = hlink;
  } else {
    clear_has_hlink();
    hlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.img_message.hlink)
}

// -------------------------------------------------------------------

// emoji_message

// required string emoji = 1;
inline bool emoji_message::has_emoji() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void emoji_message::set_has_emoji() {
  _has_bits_[0] |= 0x00000001u;
}
inline void emoji_message::clear_has_emoji() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void emoji_message::clear_emoji() {
  if (emoji_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    emoji_->clear();
  }
  clear_has_emoji();
}
inline const ::std::string& emoji_message::emoji() const {
  // @@protoc_insertion_point(field_get:message.emoji_message.emoji)
  return *emoji_;
}
inline void emoji_message::set_emoji(const ::std::string& value) {
  set_has_emoji();
  if (emoji_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    emoji_ = new ::std::string;
  }
  emoji_->assign(value);
  // @@protoc_insertion_point(field_set:message.emoji_message.emoji)
}
inline void emoji_message::set_emoji(const char* value) {
  set_has_emoji();
  if (emoji_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    emoji_ = new ::std::string;
  }
  emoji_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.emoji_message.emoji)
}
inline void emoji_message::set_emoji(const char* value, size_t size) {
  set_has_emoji();
  if (emoji_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    emoji_ = new ::std::string;
  }
  emoji_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.emoji_message.emoji)
}
inline ::std::string* emoji_message::mutable_emoji() {
  set_has_emoji();
  if (emoji_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    emoji_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.emoji_message.emoji)
  return emoji_;
}
inline ::std::string* emoji_message::release_emoji() {
  clear_has_emoji();
  if (emoji_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = emoji_;
    emoji_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void emoji_message::set_allocated_emoji(::std::string* emoji) {
  if (emoji_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete emoji_;
  }
  if (emoji) {
    set_has_emoji();
    emoji_ = emoji;
  } else {
    clear_has_emoji();
    emoji_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.emoji_message.emoji)
}

// optional string theme = 2;
inline bool emoji_message::has_theme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void emoji_message::set_has_theme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void emoji_message::clear_has_theme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void emoji_message::clear_theme() {
  if (theme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    theme_->clear();
  }
  clear_has_theme();
}
inline const ::std::string& emoji_message::theme() const {
  // @@protoc_insertion_point(field_get:message.emoji_message.theme)
  return *theme_;
}
inline void emoji_message::set_theme(const ::std::string& value) {
  set_has_theme();
  if (theme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    theme_ = new ::std::string;
  }
  theme_->assign(value);
  // @@protoc_insertion_point(field_set:message.emoji_message.theme)
}
inline void emoji_message::set_theme(const char* value) {
  set_has_theme();
  if (theme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    theme_ = new ::std::string;
  }
  theme_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.emoji_message.theme)
}
inline void emoji_message::set_theme(const char* value, size_t size) {
  set_has_theme();
  if (theme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    theme_ = new ::std::string;
  }
  theme_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.emoji_message.theme)
}
inline ::std::string* emoji_message::mutable_theme() {
  set_has_theme();
  if (theme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    theme_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.emoji_message.theme)
  return theme_;
}
inline ::std::string* emoji_message::release_theme() {
  clear_has_theme();
  if (theme_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = theme_;
    theme_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void emoji_message::set_allocated_theme(::std::string* theme) {
  if (theme_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete theme_;
  }
  if (theme) {
    set_has_theme();
    theme_ = theme;
  } else {
    clear_has_theme();
    theme_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.emoji_message.theme)
}

// optional bytes custom_image = 3;
inline bool emoji_message::has_custom_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void emoji_message::set_has_custom_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void emoji_message::clear_has_custom_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void emoji_message::clear_custom_image() {
  if (custom_image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_image_->clear();
  }
  clear_has_custom_image();
}
inline const ::std::string& emoji_message::custom_image() const {
  // @@protoc_insertion_point(field_get:message.emoji_message.custom_image)
  return *custom_image_;
}
inline void emoji_message::set_custom_image(const ::std::string& value) {
  set_has_custom_image();
  if (custom_image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_image_ = new ::std::string;
  }
  custom_image_->assign(value);
  // @@protoc_insertion_point(field_set:message.emoji_message.custom_image)
}
inline void emoji_message::set_custom_image(const char* value) {
  set_has_custom_image();
  if (custom_image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_image_ = new ::std::string;
  }
  custom_image_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.emoji_message.custom_image)
}
inline void emoji_message::set_custom_image(const void* value, size_t size) {
  set_has_custom_image();
  if (custom_image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_image_ = new ::std::string;
  }
  custom_image_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.emoji_message.custom_image)
}
inline ::std::string* emoji_message::mutable_custom_image() {
  set_has_custom_image();
  if (custom_image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    custom_image_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.emoji_message.custom_image)
  return custom_image_;
}
inline ::std::string* emoji_message::release_custom_image() {
  clear_has_custom_image();
  if (custom_image_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = custom_image_;
    custom_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void emoji_message::set_allocated_custom_image(::std::string* custom_image) {
  if (custom_image_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete custom_image_;
  }
  if (custom_image) {
    set_has_custom_image();
    custom_image_ = custom_image;
  } else {
    clear_has_custom_image();
    custom_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.emoji_message.custom_image)
}

// -------------------------------------------------------------------

// symmetry_encryption_key_distribution

// required .message.symmetry_encryption_key_distribution.EncryptionType keytype = 1;
inline bool symmetry_encryption_key_distribution::has_keytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void symmetry_encryption_key_distribution::set_has_keytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void symmetry_encryption_key_distribution::clear_has_keytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void symmetry_encryption_key_distribution::clear_keytype() {
  keytype_ = 0;
  clear_has_keytype();
}
inline ::message::symmetry_encryption_key_distribution_EncryptionType symmetry_encryption_key_distribution::keytype() const {
  // @@protoc_insertion_point(field_get:message.symmetry_encryption_key_distribution.keytype)
  return static_cast< ::message::symmetry_encryption_key_distribution_EncryptionType >(keytype_);
}
inline void symmetry_encryption_key_distribution::set_keytype(::message::symmetry_encryption_key_distribution_EncryptionType value) {
  assert(::message::symmetry_encryption_key_distribution_EncryptionType_IsValid(value));
  set_has_keytype();
  keytype_ = value;
  // @@protoc_insertion_point(field_set:message.symmetry_encryption_key_distribution.keytype)
}

// required bytes key = 2;
inline bool symmetry_encryption_key_distribution::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void symmetry_encryption_key_distribution::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void symmetry_encryption_key_distribution::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void symmetry_encryption_key_distribution::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& symmetry_encryption_key_distribution::key() const {
  // @@protoc_insertion_point(field_get:message.symmetry_encryption_key_distribution.key)
  return *key_;
}
inline void symmetry_encryption_key_distribution::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:message.symmetry_encryption_key_distribution.key)
}
inline void symmetry_encryption_key_distribution::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.symmetry_encryption_key_distribution.key)
}
inline void symmetry_encryption_key_distribution::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.symmetry_encryption_key_distribution.key)
}
inline ::std::string* symmetry_encryption_key_distribution::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.symmetry_encryption_key_distribution.key)
  return key_;
}
inline ::std::string* symmetry_encryption_key_distribution::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void symmetry_encryption_key_distribution::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.symmetry_encryption_key_distribution.key)
}

// -------------------------------------------------------------------

// avim_message

// optional .message.text_message item_text = 1;
inline bool avim_message::has_item_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void avim_message::set_has_item_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void avim_message::clear_has_item_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void avim_message::clear_item_text() {
  if (item_text_ != NULL) item_text_->::message::text_message::Clear();
  clear_has_item_text();
}
inline const ::message::text_message& avim_message::item_text() const {
  // @@protoc_insertion_point(field_get:message.avim_message.item_text)
  return item_text_ != NULL ? *item_text_ : *default_instance_->item_text_;
}
inline ::message::text_message* avim_message::mutable_item_text() {
  set_has_item_text();
  if (item_text_ == NULL) item_text_ = new ::message::text_message;
  // @@protoc_insertion_point(field_mutable:message.avim_message.item_text)
  return item_text_;
}
inline ::message::text_message* avim_message::release_item_text() {
  clear_has_item_text();
  ::message::text_message* temp = item_text_;
  item_text_ = NULL;
  return temp;
}
inline void avim_message::set_allocated_item_text(::message::text_message* item_text) {
  delete item_text_;
  item_text_ = item_text;
  if (item_text) {
    set_has_item_text();
  } else {
    clear_has_item_text();
  }
  // @@protoc_insertion_point(field_set_allocated:message.avim_message.item_text)
}

// optional .message.img_message item_image = 2;
inline bool avim_message::has_item_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void avim_message::set_has_item_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void avim_message::clear_has_item_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void avim_message::clear_item_image() {
  if (item_image_ != NULL) item_image_->::message::img_message::Clear();
  clear_has_item_image();
}
inline const ::message::img_message& avim_message::item_image() const {
  // @@protoc_insertion_point(field_get:message.avim_message.item_image)
  return item_image_ != NULL ? *item_image_ : *default_instance_->item_image_;
}
inline ::message::img_message* avim_message::mutable_item_image() {
  set_has_item_image();
  if (item_image_ == NULL) item_image_ = new ::message::img_message;
  // @@protoc_insertion_point(field_mutable:message.avim_message.item_image)
  return item_image_;
}
inline ::message::img_message* avim_message::release_item_image() {
  clear_has_item_image();
  ::message::img_message* temp = item_image_;
  item_image_ = NULL;
  return temp;
}
inline void avim_message::set_allocated_item_image(::message::img_message* item_image) {
  delete item_image_;
  item_image_ = item_image;
  if (item_image) {
    set_has_item_image();
  } else {
    clear_has_item_image();
  }
  // @@protoc_insertion_point(field_set_allocated:message.avim_message.item_image)
}

// optional .message.emoji_message item_emoji = 3;
inline bool avim_message::has_item_emoji() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void avim_message::set_has_item_emoji() {
  _has_bits_[0] |= 0x00000004u;
}
inline void avim_message::clear_has_item_emoji() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void avim_message::clear_item_emoji() {
  if (item_emoji_ != NULL) item_emoji_->::message::emoji_message::Clear();
  clear_has_item_emoji();
}
inline const ::message::emoji_message& avim_message::item_emoji() const {
  // @@protoc_insertion_point(field_get:message.avim_message.item_emoji)
  return item_emoji_ != NULL ? *item_emoji_ : *default_instance_->item_emoji_;
}
inline ::message::emoji_message* avim_message::mutable_item_emoji() {
  set_has_item_emoji();
  if (item_emoji_ == NULL) item_emoji_ = new ::message::emoji_message;
  // @@protoc_insertion_point(field_mutable:message.avim_message.item_emoji)
  return item_emoji_;
}
inline ::message::emoji_message* avim_message::release_item_emoji() {
  clear_has_item_emoji();
  ::message::emoji_message* temp = item_emoji_;
  item_emoji_ = NULL;
  return temp;
}
inline void avim_message::set_allocated_item_emoji(::message::emoji_message* item_emoji) {
  delete item_emoji_;
  item_emoji_ = item_emoji;
  if (item_emoji) {
    set_has_item_emoji();
  } else {
    clear_has_item_emoji();
  }
  // @@protoc_insertion_point(field_set_allocated:message.avim_message.item_emoji)
}

// optional .message.symmetry_encryption_key_distribution item_key = 20;
inline bool avim_message::has_item_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void avim_message::set_has_item_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void avim_message::clear_has_item_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void avim_message::clear_item_key() {
  if (item_key_ != NULL) item_key_->::message::symmetry_encryption_key_distribution::Clear();
  clear_has_item_key();
}
inline const ::message::symmetry_encryption_key_distribution& avim_message::item_key() const {
  // @@protoc_insertion_point(field_get:message.avim_message.item_key)
  return item_key_ != NULL ? *item_key_ : *default_instance_->item_key_;
}
inline ::message::symmetry_encryption_key_distribution* avim_message::mutable_item_key() {
  set_has_item_key();
  if (item_key_ == NULL) item_key_ = new ::message::symmetry_encryption_key_distribution;
  // @@protoc_insertion_point(field_mutable:message.avim_message.item_key)
  return item_key_;
}
inline ::message::symmetry_encryption_key_distribution* avim_message::release_item_key() {
  clear_has_item_key();
  ::message::symmetry_encryption_key_distribution* temp = item_key_;
  item_key_ = NULL;
  return temp;
}
inline void avim_message::set_allocated_item_key(::message::symmetry_encryption_key_distribution* item_key) {
  delete item_key_;
  item_key_ = item_key;
  if (item_key) {
    set_has_item_key();
  } else {
    clear_has_item_key();
  }
  // @@protoc_insertion_point(field_set_allocated:message.avim_message.item_key)
}

// -------------------------------------------------------------------

// message_packet

// repeated .message.avim_message avim = 1;
inline int message_packet::avim_size() const {
  return avim_.size();
}
inline void message_packet::clear_avim() {
  avim_.Clear();
}
inline const ::message::avim_message& message_packet::avim(int index) const {
  // @@protoc_insertion_point(field_get:message.message_packet.avim)
  return avim_.Get(index);
}
inline ::message::avim_message* message_packet::mutable_avim(int index) {
  // @@protoc_insertion_point(field_mutable:message.message_packet.avim)
  return avim_.Mutable(index);
}
inline ::message::avim_message* message_packet::add_avim() {
  // @@protoc_insertion_point(field_add:message.message_packet.avim)
  return avim_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::avim_message >&
message_packet::avim() const {
  // @@protoc_insertion_point(field_list:message.message_packet.avim)
  return avim_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::avim_message >*
message_packet::mutable_avim() {
  // @@protoc_insertion_point(field_mutable_list:message.message_packet.avim)
  return &avim_;
}

// optional uint64 serial = 2;
inline bool message_packet::has_serial() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_packet::set_has_serial() {
  _has_bits_[0] |= 0x00000002u;
}
inline void message_packet::clear_has_serial() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void message_packet::clear_serial() {
  serial_ = GOOGLE_ULONGLONG(0);
  clear_has_serial();
}
inline ::google::protobuf::uint64 message_packet::serial() const {
  // @@protoc_insertion_point(field_get:message.message_packet.serial)
  return serial_;
}
inline void message_packet::set_serial(::google::protobuf::uint64 value) {
  set_has_serial();
  serial_ = value;
  // @@protoc_insertion_point(field_set:message.message_packet.serial)
}

// optional .proto.av_address sender = 3;
inline bool message_packet::has_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void message_packet::set_has_sender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void message_packet::clear_has_sender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void message_packet::clear_sender() {
  if (sender_ != NULL) sender_->::proto::av_address::Clear();
  clear_has_sender();
}
inline const ::proto::av_address& message_packet::sender() const {
  // @@protoc_insertion_point(field_get:message.message_packet.sender)
  return sender_ != NULL ? *sender_ : *default_instance_->sender_;
}
inline ::proto::av_address* message_packet::mutable_sender() {
  set_has_sender();
  if (sender_ == NULL) sender_ = new ::proto::av_address;
  // @@protoc_insertion_point(field_mutable:message.message_packet.sender)
  return sender_;
}
inline ::proto::av_address* message_packet::release_sender() {
  clear_has_sender();
  ::proto::av_address* temp = sender_;
  sender_ = NULL;
  return temp;
}
inline void message_packet::set_allocated_sender(::proto::av_address* sender) {
  delete sender_;
  sender_ = sender;
  if (sender) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
  // @@protoc_insertion_point(field_set_allocated:message.message_packet.sender)
}

// -------------------------------------------------------------------

// group_security_key

// required bytes key = 1;
inline bool group_security_key::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void group_security_key::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void group_security_key::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void group_security_key::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& group_security_key::key() const {
  // @@protoc_insertion_point(field_get:message.group_security_key.key)
  return *key_;
}
inline void group_security_key::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:message.group_security_key.key)
}
inline void group_security_key::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.group_security_key.key)
}
inline void group_security_key::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.group_security_key.key)
}
inline ::std::string* group_security_key::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.group_security_key.key)
  return key_;
}
inline ::std::string* group_security_key::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void group_security_key::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.group_security_key.key)
}

// required bytes prev_key = 2;
inline bool group_security_key::has_prev_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void group_security_key::set_has_prev_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void group_security_key::clear_has_prev_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void group_security_key::clear_prev_key() {
  if (prev_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_key_->clear();
  }
  clear_has_prev_key();
}
inline const ::std::string& group_security_key::prev_key() const {
  // @@protoc_insertion_point(field_get:message.group_security_key.prev_key)
  return *prev_key_;
}
inline void group_security_key::set_prev_key(const ::std::string& value) {
  set_has_prev_key();
  if (prev_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_key_ = new ::std::string;
  }
  prev_key_->assign(value);
  // @@protoc_insertion_point(field_set:message.group_security_key.prev_key)
}
inline void group_security_key::set_prev_key(const char* value) {
  set_has_prev_key();
  if (prev_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_key_ = new ::std::string;
  }
  prev_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:message.group_security_key.prev_key)
}
inline void group_security_key::set_prev_key(const void* value, size_t size) {
  set_has_prev_key();
  if (prev_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_key_ = new ::std::string;
  }
  prev_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message.group_security_key.prev_key)
}
inline ::std::string* group_security_key::mutable_prev_key() {
  set_has_prev_key();
  if (prev_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prev_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:message.group_security_key.prev_key)
  return prev_key_;
}
inline ::std::string* group_security_key::release_prev_key() {
  clear_has_prev_key();
  if (prev_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = prev_key_;
    prev_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void group_security_key::set_allocated_prev_key(::std::string* prev_key) {
  if (prev_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prev_key_;
  }
  if (prev_key) {
    set_has_prev_key();
    prev_key_ = prev_key;
  } else {
    clear_has_prev_key();
    prev_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:message.group_security_key.prev_key)
}

// required uint64 valid_until = 3;
inline bool group_security_key::has_valid_until() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void group_security_key::set_has_valid_until() {
  _has_bits_[0] |= 0x00000004u;
}
inline void group_security_key::clear_has_valid_until() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void group_security_key::clear_valid_until() {
  valid_until_ = GOOGLE_ULONGLONG(0);
  clear_has_valid_until();
}
inline ::google::protobuf::uint64 group_security_key::valid_until() const {
  // @@protoc_insertion_point(field_get:message.group_security_key.valid_until)
  return valid_until_;
}
inline void group_security_key::set_valid_until(::google::protobuf::uint64 value) {
  set_has_valid_until();
  valid_until_ = value;
  // @@protoc_insertion_point(field_set:message.group_security_key.valid_until)
}

// required uint32 key_id = 4;
inline bool group_security_key::has_key_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void group_security_key::set_has_key_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void group_security_key::clear_has_key_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void group_security_key::clear_key_id() {
  key_id_ = 0u;
  clear_has_key_id();
}
inline ::google::protobuf::uint32 group_security_key::key_id() const {
  // @@protoc_insertion_point(field_get:message.group_security_key.key_id)
  return key_id_;
}
inline void group_security_key::set_key_id(::google::protobuf::uint32 value) {
  set_has_key_id();
  key_id_ = value;
  // @@protoc_insertion_point(field_set:message.group_security_key.key_id)
}

// -------------------------------------------------------------------

// control_message_buddy_state_notify

// required .proto.av_address who = 1;
inline bool control_message_buddy_state_notify::has_who() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void control_message_buddy_state_notify::set_has_who() {
  _has_bits_[0] |= 0x00000001u;
}
inline void control_message_buddy_state_notify::clear_has_who() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void control_message_buddy_state_notify::clear_who() {
  if (who_ != NULL) who_->::proto::av_address::Clear();
  clear_has_who();
}
inline const ::proto::av_address& control_message_buddy_state_notify::who() const {
  // @@protoc_insertion_point(field_get:message.control_message.buddy_state_notify.who)
  return who_ != NULL ? *who_ : *default_instance_->who_;
}
inline ::proto::av_address* control_message_buddy_state_notify::mutable_who() {
  set_has_who();
  if (who_ == NULL) who_ = new ::proto::av_address;
  // @@protoc_insertion_point(field_mutable:message.control_message.buddy_state_notify.who)
  return who_;
}
inline ::proto::av_address* control_message_buddy_state_notify::release_who() {
  clear_has_who();
  ::proto::av_address* temp = who_;
  who_ = NULL;
  return temp;
}
inline void control_message_buddy_state_notify::set_allocated_who(::proto::av_address* who) {
  delete who_;
  who_ = who;
  if (who) {
    set_has_who();
  } else {
    clear_has_who();
  }
  // @@protoc_insertion_point(field_set_allocated:message.control_message.buddy_state_notify.who)
}

// required .message.control_message.buddy_state state = 2;
inline bool control_message_buddy_state_notify::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void control_message_buddy_state_notify::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void control_message_buddy_state_notify::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void control_message_buddy_state_notify::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::message::control_message_buddy_state control_message_buddy_state_notify::state() const {
  // @@protoc_insertion_point(field_get:message.control_message.buddy_state_notify.state)
  return static_cast< ::message::control_message_buddy_state >(state_);
}
inline void control_message_buddy_state_notify::set_state(::message::control_message_buddy_state value) {
  assert(::message::control_message_buddy_state_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:message.control_message.buddy_state_notify.state)
}

// -------------------------------------------------------------------

// control_message

// optional .proto.av_address sender = 1;
inline bool control_message::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void control_message::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void control_message::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void control_message::clear_sender() {
  if (sender_ != NULL) sender_->::proto::av_address::Clear();
  clear_has_sender();
}
inline const ::proto::av_address& control_message::sender() const {
  // @@protoc_insertion_point(field_get:message.control_message.sender)
  return sender_ != NULL ? *sender_ : *default_instance_->sender_;
}
inline ::proto::av_address* control_message::mutable_sender() {
  set_has_sender();
  if (sender_ == NULL) sender_ = new ::proto::av_address;
  // @@protoc_insertion_point(field_mutable:message.control_message.sender)
  return sender_;
}
inline ::proto::av_address* control_message::release_sender() {
  clear_has_sender();
  ::proto::av_address* temp = sender_;
  sender_ = NULL;
  return temp;
}
inline void control_message::set_allocated_sender(::proto::av_address* sender) {
  delete sender_;
  sender_ = sender;
  if (sender) {
    set_has_sender();
  } else {
    clear_has_sender();
  }
  // @@protoc_insertion_point(field_set_allocated:message.control_message.sender)
}

// optional .message.group_security_key group_key = 2;
inline bool control_message::has_group_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void control_message::set_has_group_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void control_message::clear_has_group_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void control_message::clear_group_key() {
  if (group_key_ != NULL) group_key_->::message::group_security_key::Clear();
  clear_has_group_key();
}
inline const ::message::group_security_key& control_message::group_key() const {
  // @@protoc_insertion_point(field_get:message.control_message.group_key)
  return group_key_ != NULL ? *group_key_ : *default_instance_->group_key_;
}
inline ::message::group_security_key* control_message::mutable_group_key() {
  set_has_group_key();
  if (group_key_ == NULL) group_key_ = new ::message::group_security_key;
  // @@protoc_insertion_point(field_mutable:message.control_message.group_key)
  return group_key_;
}
inline ::message::group_security_key* control_message::release_group_key() {
  clear_has_group_key();
  ::message::group_security_key* temp = group_key_;
  group_key_ = NULL;
  return temp;
}
inline void control_message::set_allocated_group_key(::message::group_security_key* group_key) {
  delete group_key_;
  group_key_ = group_key;
  if (group_key) {
    set_has_group_key();
  } else {
    clear_has_group_key();
  }
  // @@protoc_insertion_point(field_set_allocated:message.control_message.group_key)
}

// repeated .proto.av_address new_bie = 3;
inline int control_message::new_bie_size() const {
  return new_bie_.size();
}
inline void control_message::clear_new_bie() {
  new_bie_.Clear();
}
inline const ::proto::av_address& control_message::new_bie(int index) const {
  // @@protoc_insertion_point(field_get:message.control_message.new_bie)
  return new_bie_.Get(index);
}
inline ::proto::av_address* control_message::mutable_new_bie(int index) {
  // @@protoc_insertion_point(field_mutable:message.control_message.new_bie)
  return new_bie_.Mutable(index);
}
inline ::proto::av_address* control_message::add_new_bie() {
  // @@protoc_insertion_point(field_add:message.control_message.new_bie)
  return new_bie_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::av_address >&
control_message::new_bie() const {
  // @@protoc_insertion_point(field_list:message.control_message.new_bie)
  return new_bie_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::av_address >*
control_message::mutable_new_bie() {
  // @@protoc_insertion_point(field_mutable_list:message.control_message.new_bie)
  return &new_bie_;
}

// repeated .proto.av_address gone_bie = 4;
inline int control_message::gone_bie_size() const {
  return gone_bie_.size();
}
inline void control_message::clear_gone_bie() {
  gone_bie_.Clear();
}
inline const ::proto::av_address& control_message::gone_bie(int index) const {
  // @@protoc_insertion_point(field_get:message.control_message.gone_bie)
  return gone_bie_.Get(index);
}
inline ::proto::av_address* control_message::mutable_gone_bie(int index) {
  // @@protoc_insertion_point(field_mutable:message.control_message.gone_bie)
  return gone_bie_.Mutable(index);
}
inline ::proto::av_address* control_message::add_gone_bie() {
  // @@protoc_insertion_point(field_add:message.control_message.gone_bie)
  return gone_bie_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::av_address >&
control_message::gone_bie() const {
  // @@protoc_insertion_point(field_list:message.control_message.gone_bie)
  return gone_bie_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::av_address >*
control_message::mutable_gone_bie() {
  // @@protoc_insertion_point(field_mutable_list:message.control_message.gone_bie)
  return &gone_bie_;
}

// repeated .message.control_message.buddy_state_notify buddy_status = 5;
inline int control_message::buddy_status_size() const {
  return buddy_status_.size();
}
inline void control_message::clear_buddy_status() {
  buddy_status_.Clear();
}
inline const ::message::control_message_buddy_state_notify& control_message::buddy_status(int index) const {
  // @@protoc_insertion_point(field_get:message.control_message.buddy_status)
  return buddy_status_.Get(index);
}
inline ::message::control_message_buddy_state_notify* control_message::mutable_buddy_status(int index) {
  // @@protoc_insertion_point(field_mutable:message.control_message.buddy_status)
  return buddy_status_.Mutable(index);
}
inline ::message::control_message_buddy_state_notify* control_message::add_buddy_status() {
  // @@protoc_insertion_point(field_add:message.control_message.buddy_status)
  return buddy_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::control_message_buddy_state_notify >&
control_message::buddy_status() const {
  // @@protoc_insertion_point(field_list:message.control_message.buddy_status)
  return buddy_status_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::control_message_buddy_state_notify >*
control_message::mutable_buddy_status() {
  // @@protoc_insertion_point(field_mutable_list:message.control_message.buddy_status)
  return &buddy_status_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::message::symmetry_encryption_key_distribution_EncryptionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::symmetry_encryption_key_distribution_EncryptionType>() {
  return ::message::symmetry_encryption_key_distribution_EncryptionType_descriptor();
}
template <> struct is_proto_enum< ::message::control_message_buddy_state> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::control_message_buddy_state>() {
  return ::message::control_message_buddy_state_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_im_2eproto__INCLUDED
